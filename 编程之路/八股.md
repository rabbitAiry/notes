## Java
- 抽象类与接口的区别
```text
相同点：不能被实例化、可以有抽象方法
不同点：抽象类可以包含普通方法、抽象方法、构造方法和静态方法，接口只能包含抽象方法静态方法和默认方法。抽象类中的成员可以是各种类型的，而接口的成员只能是public static final的
```
- 重载和重写的区别
```text
重载是同一个类中方法同名但是参数列表不相同
重写发生在基础中，子类方法覆盖父类方法的过程，参数列表必须相同，并且权限修饰符要大于等于父类方法，声明异常不多于父类方法。父类的final和private方法不可重写
```
- `==`与equals的区别
```text
==比较的是是否是同一个对象，比较的是内存地址
equals可以根据重写实现需要的对比逻辑。重写equals后还需要重写hashcode方法
```
- 异常处理机制
```text
try-catch-finally
异常会向上抛出，直到找到能够解决该异常的异常处理机制
使用throw抛出异常
```
- final和static关键字
```text
final通常表示修饰内容不可被修改
final修饰引用时表示引用所指向的对象不可被修改
final修饰方法表示方法不可被重写
final修饰类表示类不能被继承
static则通常表示静态属性，修饰对象或者方法时表示该对象或方法在类中只有一份，是属于类的
```
- 单例模式
```text
饿汉式、懒汉式
```
- 面向对象的三大特点
```text
封装，继承，多态
```
- 堆、栈、方法区
```text
堆存储对象
栈存储引用
方法区存储类信息
```
- 垃圾回收机制
```text
JVM在内存快要满时触发一次GC。GC会找到不可达的对象，并将其进行标记，然后筛选出对象，并在调用finallize方法后再次进行标记。没有必要执行finallize()方法的对象会被回收掉
```
- 强软弱虚引用
```text
强引用不会被回收
软引用会在内存不够用的时候被回收
弱引用会在每次触发GC时被回收
虚引用随时可能被回收
```
- HashMap原理
```text
基于数组+链表+红黑树来实现，线程不安全
扩容需求基于容量*负载因子是否大于元素数量
使用尾插法
```
- 使用线程安全的HashMap，及其原理
```text
使用ConcurrentHashMap或者HashTable
前者通过分段锁1.7/CAS+synchronized保证线程安全
后者采用每个方法使用synchronized修饰保证线程安全
```
- 什么是反射
```text
反射通过获取类的Class对象，然后动态地获取类的内部结构，并动态地操作类的属性和方法
```
- Java创建对象的五种方式
```text
- new
- 反射Class.newInstance
- 反射Constructor.newInstance
- Clone方法
- 反序列化
```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```
- 进程和线程的区别
```text
进程是操作系统中，一个应用的启动与执行
线程是CPU调度的最小单位，每个进程中至少包含一个线程
```
- 什么是上下文切换
```text
线程执行期间停下来，CPU切换到其他线程执行
```
- 什么是死锁
```text
两个线程互相持有了让对方继续执行的锁，导致线程因争夺资源而导致了互相等待
```
- 死锁的条件
```text
互斥条件：同一资源同时只能由一个线程读取
不可抢占条件：不能强行剥夺线程占有的资源
请求和保持条件：请求其他资源的同时对自己手中的资源保持不放
循环等待条件：在相互等待资源
```
- 预防死锁
```text
使用定时锁、尽量让线程用相同的加锁顺序
```
- Synchronized和lock的区别
```text
- synchronized是关键字，而lock是一个类
- synchronized在发生异常时会自动释放锁，lock需要手动释放
- synchronized是可重入锁、非公平锁、不可中断锁，lock的ReetrantLock是可重入锁、可中断锁、公平与否由参数决定
- synchronized是JVM层次通过监视器实现的，Lock是通过AQS实现的
```
- 什么是AQS锁
```text
- AQS是一个抽象类，可以用来构造锁和同步工具，包括ReentrantLock、CountDownLatch等
- AQS的原理是通过CAS将state设为1得到锁，设为0释放锁。等待锁的线程会加入阻塞队列
```
- 为什么AQS锁的阻塞队列使用双向链表
```text
因为有一些线程可能会发生中断，而发生中断时候就需要在同步阻塞队列中删除掉，使用双向链表容易删除中间节点
```
- 常见的AQS锁
```text
- ReetrantLock独占锁
- Semaphore信号量
- CountDownLatch倒计时器
- CyclicBarrier循环栅栏
```
- sleep()和wait()的区别
```text
- wait()是Object的方法，sleep()是Thread的方法
- wait会释放锁，sleep不会
- wait要在同步方法或者同步代码块内执行
- wait需要通过notify唤醒
```
- yield()和join()的区别
```text
yield调用后线程进入RUNNABLE就绪状态
A线程调用B线程的join，则A会在B线程执行完前进入阻塞状态
```
- 线程池七参数
```text
核心线程池数量、最大线程池数量、最大存活时间、最大存活时间单位、线程工厂、拒绝策略、阻塞队列
```
- Java内存模型概述
```text
JMM屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各平台下达到一致的内存访问效果，定义了JVM如何将程序中的变量在主存中读取
具体定义为：所有变量都存主存中，主存是线程共享区域；每个线程拥有自己独立的工作内存
```
- 保证并发的三大特性
```text
原子性：操作在执行期间不受其他线程影响
可见性：共享变量不应该存储在线程的独立工作内存中
有序性：禁止指令重排
```
- volatile的作用
```text
保证了变量的可见性和有序性
```
- ThreadLocal原理及如何解决内存泄漏
```text
每个线程内部维护了一个Map，其键为ThreadLocal，值为存储内容
因为key为弱引用，value为强引用，所以会导致内存泄漏。
可以通过在每次使用完后删除value或者使用static修饰ThreadLocal使其变为强引用
```
- 什么是CAS锁
```text
比较，符合预期则更新
CAS锁可以保证原子性，但是CAS锁只能支持一个变量的原子操作，且在频繁失败时会导致CPU开销大，以及存在ABA问题
```
- Synchronized锁的原理
```text
Synchronized通过JVM监视器实现其功能，依赖操作系统的互斥锁实现
```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

```text

```

## 网络
- TCP/IP模型
```text
应用层、传输层、网络层、网络接口层
```
- 浏览器输入地址后做了什么
```text
浏览器查找域名的IP地址
浏览器向Web服务器发起HTTP请求
服务器处理请求，发回一个HTML响应
浏览器显式HTML
```
- TCP为什么不能两次握手
```text
假若是两次握手，如果客户端未能够接收到服务器端的回应，于是重新发生了 连接请求，进行了两次连接。当服务器端与客户端最新一次连接结束后，服务器端仍进入了连接状态，但是客户端不会响应服务端的连接确认报文
```
- TCP为什么要进入时间等待状态
```text
在TCP四次挥手中的时间等待状态是为了让服务器端将需要发送的数据都发送完
```
- 谈谈TCP滑动窗口
```text
TCP流量控制依靠滑动窗口，窗口大小是接收端所能接收的缓存大小
```
- TCP拥塞控制
```text
拥塞窗口的大小取决于网络的拥塞程度
```
- TCP超时重传
```text
发送方在一定时间内无法接收到响应，就会重发上一则报文
```
- TCP可靠传输的实现
```text
基于停止等待、自动重传的ARQ协议实现可靠传输，又通过基于滑动窗口、累计确认的连续ARQ协议提高效率
```
- 状态码
```text
1xx：请求正在处理
2xx：请求成功处理
3xx：请求重定向等
4xx：请求错误等
5xx：服务端错误
```
- https
```text
https是HTTP和SSL协议构建的可进行加密传输、身份认证的安全性网络协议
SSL协议位于传输层和应用层之间
SSL握手流程保证了数据安全：TCP握手后进行SSL握手，过程包括了发送证书、告知加密套件、SSL版本公钥
```
- socket编程流程
```text
- 服务器端创建Socket并使用listen()建立监听
- 客户端创建Socket并调用connect()发起连接请求
- 服务器端Socket监听到客户端请求后被动打开，调用accept()接收客户但请求
- 客户端通过close()结束连接
```

```text

```

```text

```

```text

```
