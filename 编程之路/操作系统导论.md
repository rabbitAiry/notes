## *1 操作系统介绍
> #2

- 操作系统
   - 负责让程序运行变得容易，甚至允许同时运行多个程序，允许程序共享内存，让程序能与设备交互
   - 虚拟化
      - 操作系统将物理资源转换为更通用、易用、强大的虚拟形式。因此有时将操作系统称为虚拟机
      - 虚拟化使得程序可以共享CPU、内存、磁盘。因此操作系统有时被称为资源管理器，操作系统负责管理资源
   - 设计目标
      - 提高性能
      - 保护
         - 确保一个程序的恶意或不良行为不会损害其他程序
         - 进程彼此隔离是保护的关键
      - 可靠性、能源效率、安全性、...等等
- 操作系统负责的内容
   - 虚拟化CPU：系统将单个CPU转换为无限数量的CPU，从而让许多程序看似同时运行
   - 虚拟化内存：每个进程访问自己的私有虚拟地址空间
   - 并发
   - 持久性
      - 操作系统中，管理磁盘的软件叫做文件系统
      - 磁盘是共享的

## *2 CPU与进程
> #4-7

- 进程
   - 操作系统为正在运行的程序提供的抽象，就是所谓的进程
   - CPU的时分共享
      - 每个进程只允许一个时间片，然后切换到其他进程
      - 造成性能损失
   - 进程的机器状态
      - 内存：存储指令和数据
      - 寄存器：许多指令明确地读取或更新寄存器。特殊的寄存器包括了程序计数器和指针等
   - 进程的运行过程
      1. 将代码和静态数据从磁盘中加载到内存上
      1. 操作系统为程序的运行时栈、堆分配内存
      1. 启动程序，执行main()
   - 进程状态
      - 运行：正在执行指令
      - 就绪：操作系统此时没有选择该进程
      - 阻塞：进程执行了诸如I/O请求的操作
   - 跟踪被阻塞的进程：当I/O事件完成时，确保唤醒进程，让它准备好
![](https://cdn.nlark.com/yuque/__mermaid_v3/9ff246fc220de718f5c24140bf983b6a.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBMUlxuaWQxLS3osIPluqYtLT5pZDMo5bCx57uqKVxuaWQzLS3lj5bmtojosIPluqYtLT5pZDFcbmlkMSjov5DooYwpLS3lj5HotbdJL08tLT5pZDIo6Zi75aGeKVxuaWQyLS3nu5PmnZ9JL08tLT5pZDMiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19tZXJtYWlkX3YzLzlmZjI0NmZjMjIwZGU3MThmNWMyNDE0MGJmOTgzYjZhLnN2ZyIsImlkIjoidVMwMEkiLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9)

- 进程相关API
   - `fork()`：用于创建新进程
         - 子进程不是从头开始执行，而是从`fork()`系统调用返后开始执行
         - 子进程和父进程的执行顺序是不确定的
   - `wait()`：等待子进程运行
   - `exec()`：使得子进程和父进程能够执行不同的程序
      - 不负责创建进程，而是直接替换运行程序
      - 当前进程的代码段、堆、栈会被重新加载和初始化
      - （test4中，将原本执行的test4替换为了wc程序）
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char const *argv[])
{
    printf("hello world(pid:%d)\n", (int)getpid());
    int rc = fork();
    if(rc<0){
        fprintf(stderr, "fork failed\n");
        exit(1);
    }else if(rc==0){
        printf("hello, I am child(pid:%d)\n", (int)getpid());
    }else{
        // wait(NULL);
        printf("hello, I am parent of %d (pid:%d)\n", rc, (int)getpid());
    }
    return 0;
}

/**
airy_ubuntu@Cola:/mnt/d/code_ex/C/OS$ ./test2
hello world(pid:138)
hello, I am parent of 139 (pid:138)
hello, I am child(pid:139)
*/
```
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>

int main(int argc, char const *argv[])
{
    printf("hello world(pid:%d)\n", (int)getpid());
    int rc = fork();
    if(rc<0){
        fprintf(stderr, "fork failed\n");
        exit(1);
    }else if(rc==0){
        printf("hello, I am child(pid:%d)\n", (int)getpid());
        char *myargs[3];
        myargs[0] = strdup("wc");   // 字符计数程序“wc”：行数、单词数、字符数
        myargs[1] = strdup("test4_exec.c"); // 统计对象
        myargs[2] = NULL;
        execvp(myargs[0], myargs);
        printf("this shoudln't print out");
    }else{
        int wc = wait(NULL);
        printf("hello, I am parent of %d (wc:%d) (pid:%d)\n", rc, wc, (int)getpid());
    }
    return 0;
}

/**
airy_ubuntu@Cola:/mnt/d/code_ex/C/OS$ gcc -o test4 test4_exec.c -Wall
airy_ubuntu@Cola:/mnt/d/code_ex/C/OS$ ./test4
hello world(pid:163)
hello, I am child(pid:164)
 27  73 755 test4_exec.c
hello, I am parent of 164 (wc:164) (pid:163)
*/
```

- 重定向（课外知识）
   - `wc test2_fork.c > temp.txt`将test2的输出结果输出到temp.txt文件中
   - 重定向在代码中实现
      - 先关闭标准输出，再打开文件，使得文件描述符得到改变
- 使用cat命令阅读文件（课外知识）：`cat temp.txt`
```c
#include <fcntl.h>

// ...
close(STDOUT_FILENO);
open("./p4.output", O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);
```

#### 受限直接执行LDE（limited direct execution）

- 目的：在时分共享的CPU中，既需要不增加系统开销从而实现高性能，又需要保留操作系统对CPU的控制权
- 直接运行协议
   - 操作系统
      - 在进程列表上创建条目
      - 为程序分配内存
      - 将程序加载到内存中
      - 根据argc/argv设置程序栈
      - 清除寄存器
      - 执行call main()方法
   - 程序
      - 执行main()
      - 从main()中执行return
   - 操作系统
      - 释放进程的内存
      - 将进程从进程列表中移除
- 受限
   - 使用陷阱表限制操作
   - 使用非协作方式使得操作系统可以随时重新获得控制权
- 用户模式与内核模式
   - 硬件提供不同的执行模式来协助操作系统（处理器模式）
   - 用户模式：此模式下运行的代码会受到限制。进程不能发出I/O请求
   - 内核模式：操作系统以这种模式运行
- 系统调用
   - 提供用户执行特权操作的能力
   - 实现原理：内核向用户暴露某些关键功能
   - 陷阱指令
      - 要执行系统调用，必须执行特殊的陷阱指令
      - 执行该指令时，跳入内核并将特权级别提升到内核模式
      - 最后，操作系统会调用“从陷阱返回”指令（return from trap）回到用户模式
      - 为了保证能够正确返回，需要有足够的寄存器。在x86上，处理器会在跳入陷阱前将寄存器保存到内核栈中
   - 陷阱表
      - 陷阱表：硬件中断时需要执行的操作
      - 在操作系统启动的第一件事，就是告诉硬件在发生中断时要执行哪些代码，以及陷阱处理程序的位置
      - 硬件会记住这些处理程序的位置，直到下一次启动机器

#### 进程间切换
> 如果一个进程在CPU上运行，就意味着操作系统没有在运行

- 协作方式
   - 操作系统相信系统进程会合理运行，运行时间过长的进程会自动放弃CPU
   - 将控制权交给操作系统的方式
      - 进行系统调用的时候
      - 应用程序执行了某些非法操作，比如除以0，或者访问无法访问的内存
   - 假如某个进程陷入无限循环，而又不进行系统调用，就会出现操作系统无法获取控制权的方式，只能通过重启电脑解决问题
- 非协作方式
   - 通过设置时钟的中断处理程序可以实现重获CPU控制权
   - 发生中断时，需要将各种寄存器保存到内核栈中，从而能够轻易恢复
- 上下文切换(context switch)
   - 上下文切换包括了保存当前进程中寄存器的值，以及恢复即将执行的寄存器的值
#### 进程调度

- 调度策略的构建
   - 工作负载（workload）：需要先假设一个工作负载的模型
   - 调度指标
      - 性能指标
         - 周转时间 = 任务完成时间 - 到达（系统收到任务）时间
         - 响应时间 = 首次执行时间 - 到达时间
      - 公平指标
- FIFO调度（FCFS先到先服务）
   - 优点：简单易实现
   - 缺点
      - 假若先到的服务十分耗时，就会导致平均的周转时间得到增加（护航效应）
      - 响应时间大
- SJF调度（最短任务优先）
   - 优点：补齐了FIFO调度的缺点
   - 缺点
      - 属于非抢占式调度。只有在耗时长的服务和耗时短的服务几乎同时到达时才能体现优势。因为非抢占式调度不会停下手头的工作，直到完成为止
      - 响应时间大
- STCF调度（最短完成时间优先）
   - 优点：属于抢占式的调度，补齐了SJF调度的缺点
   - 缺点：响应时间大
- 轮转（RR）调度
   - RR在一个时间片内运行一个工作，然后切换到队列中的下一个任务
   - 时间片不宜太短，因为上下文切换是有成本的
   - 优点
      - 响应时间短
      - 公平
   - 缺点：周转时间增加
- 重叠(overlap)：当前进程在发起I/O操作时，将CPU交由其他进程


## *3 内存

- 虚拟化内存
	- 时分共享的进程如何使用内存
		- 使用磁盘作临时保存的方案比较耗时
		- 驻留在内存中的方案因为快而得到选择
	- 虚拟的地址空间
		- 操作系统提供给程序的易用的物理内存抽象。地址空间会被加载在任意的物理地址
		- 地址空间包含了程序运行的代码、保存调用信息的栈，以及动态分配内存的堆等
	- 虚拟内存的目标
		- 透明：程序不知道自己的地址空间是被虚拟化的
		- 效率
		- 保护：通过隔离的方式确保操作系统或进程不会受到其他进程影响
```C
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]){

    printf("loaction of code : %p\n", (void *)main);

    printf("loaction of heap : %p\n", (void *)malloc(1));

    int x = 3;

    printf("loaction of stack : %p\n", (void *)&x);

    return x;

}
```

- 内存类型(C语言)
	- 栈内存：编译器会自动为这些内存申请和释放
	- 堆内存
		- `malloc()`申请内存
			- 例子：`double *d = (double *) malloc(sizeof(double))` 
		- `free()`释放内存
			- 例子：`free(d)`
		- 操作系统对于内存申请和释放的支持
			- 系统调用brk：用于改变程序分断的位置


## *4 I/O设备

- I/O
	- 在系统架构中
		- 图像或高性能的I/O设备通过常规I/O总线连接到系统
		- SCSI、SATA或者USB通过外设I/O总线连接到系统
		- 这样的分层架构基于“高性能的设备离CPU近一些”的思路
	- 标准设备包括了硬件接口和内部结构
	- 标准协议
		- 设备接口包括了3个寄存器
			- 状态寄存器：可以读取并查看设备当前的状态
			- 命令寄存器：用于通知设备执行某个具体任务
			- 数据寄存器：负责数据与设备之间的传递/接收
		- 标准协议描述的设备与操作系统的交互
			1. 轮询polling：操作系统反复读取寄存器，等待设备进入可以接收命令的就绪状态
			2. 操作系统下发数据到数据寄存器。如果主CPU参与数据活动，则称为编程的I/O（PIO）
			3. 操作系统将命令写入命令寄存器
			4. 操作系统不断轮询，直到确定设备执行完成命令
	- 减少轮询开销
		- 频繁轮询增加了CPU的开销
		- 通过中断取代了轮询：当设备完成自身操作，会抛出一个硬件中断
		- 如果使用I/O的时间非常的短，使用中断反而会增加时间
	- 进行高效的数据传送
		- 使用PIO将一大块数据传给设备，浪费了CPU的时间和算力
		- 通过DMA（Direct Memory Access）可以协调完成内存和设备之间的数据传递，不需要CPU介入
	- 活锁
		- 短时间内出现大量的中断导致操作系统不断处理中断，从而无法处理用户层的请求
	- 设备交互的方法
		- I/O指令：特权指令
		- 内存映射I/O：硬件将设备寄存器作为内存地址提供
	- 设备驱动程序
- 应用程序对I/O的使用
	- 操作系统和硬盘一般是按块批量传输，而不是按字节，以摊销延时开销
	- 文件描述符
		- 打开文件会在操作系统内核建立文件描述符
	- 一般读写文件需要两次数据复制
		- 应用程序操作数据需要经过操作系统内核
		- 因此读写数据包括了两次环境的切换：从用户态到内核态
	- 使用缓冲区提高效率
		- 一次读取较多内容放到缓冲区，然后直接从缓存区读
		- 写入内容到缓冲区直到满了，然后再一次性调用操作系统写到硬盘
		- 在写入操作结束时，将缓冲区的剩余内容同步到硬盘


## *5 分布式系统
