> **来不及刷的题目**
> 

##### #4 寻找两个有序数组的中位数

1.   合并数组
     -   形式上合并数组：创建新数组，再返回中间值
     -   思想上合并数组：显然可以直到中间值是第几个数，于是使用双指针即可
2.   使用二分查找排除中位数前的数
     -   令中位数为两者合并后的第k位数，既然不能直接排除前k位，则排除前k/2位
     -   通过比较，可以直到应该排除哪个数组中的前k/2位
     -   不断排除前k/2位，并不断更新k值（k的定义未变），直到k\==1时，返回两个数组中第一小的值

-   思考
    -   二分查找就是通过缩小范围，但这题的二分查找并没有通过左右指针的方式，而是令k值不断除以二，直到其值为1
    -   在二分查找上，一开始想的是直接找到最中间的两个数字或者一个数字，但是因为涉及奇偶性问题使得很难写出代码。题解的做法是：不是找到最中间的数，而是根据奇偶性找到第i个数



##### #7 整数翻转now

> 数学

- 思路
  1. 这道题的重头戏在如何处理正负，以及如何判断溢出。值得一提的是，java中负数的除法、求余得到的都是负数，所以正负数的操作是一致的。判断上可以先判断当前值是否大于最大值除以10，再比较加上的数是否会大于最大值mod10
  2. 答案的方法，通过简单的不等式和讨论条件推导，使得判断条件变得格外简单。在设计计算的问题上，不妨也先这样试一下
- 未通过
	- 忘记负数的余数也是负数了
	- 加减运算的溢出会让数值变成符号相反，但是乘法可能不会带来这种正负变换



##### #8 字符串转换整数

- 未通过
  - 输入字符串为空
  - 输出字符串转Integer时为空
  - index自增下判断没有正确判断空值



##### #10 正则表达式匹配

1.   动态规划

-   思考
    -   因为涉及区间划分需要枚举，所以想到使用动态规划。但是不知道怎么表示状态之间的转移，甚至一开始连转移的意义都没想到



##### #11 盛最多水的容器

1. 暴力 超时
2. 暴力 优化
    -   `s = h*l`
    -   对外循环的i进行限制：若该数字比前一位小，则意味着h、l都减小了，不可能再次产生最大值，因此跳过。能通过但耗时较长
3. 双指针
    -   通过公式知道了面积由距离和两者高度最小值共同决定，但是高度最小值并不可控，所以从距离下手
    -   距离的最大值为数组的长度len-1，所以应该从两头开始向中间遍历这个数组
    -   想到最佳的答案一定会是两个边界数值都相对较大，所以在遍历过程中，每次只让矩形长度减一，放弃左右指针中的最小值
    -   复杂度为O(n)



##### #12 整数转罗马数字

- 思路
  1. 罗列出所有可能性，叠加



##### #13 罗马数字转整数

- 思路
  1. 通过判断下一个char所代表的数字比当前char代表数字要大来判定：当前是一个字母代表一个数字还是两个字母（如：IV）代表一个数字




##### #16 最接近的三数之和

> 双指针

- 思路
  1. 与15类似。但是有一点要注意，最大值尽量不要直接写Integer.MAX_VALUE，而是依据题目设定，尤其是出现最大值减去一个负数的时候



##### #17 电话号码的字母组合

> 枚举、回溯（dfs）

- 思路
  1. 直接枚举即可，要注意安排顺序



##### #20 有效的括号

-   未通过
    -   冷知识：`stack.peek()`在栈空时返回null，虽然我觉得null和一个数字对比一定是不相等的，但是正是因为对比对象是一个数字，所以java会对此进行拆包，所以出现NullPointerException报错



##### #22 括号生成

1.   回溯
     -   符合条件的字符串，需要保证右括号不会大于左括号的数量，左括号不会大于括号数量。基于此条件进行递归



##### #23 合并k个排序链表

1.   暴力
     -   时间复杂度为O(kn)，n为所有节点数量
2.   暴力-优化
     -   在【合并2个排序链表】中，并不是所有的节点都会比较一次，假若任意链表已经为空，则可以直接替换。
     -   因此令所有链表不断与答案链表合并，最后生成唯一的链表，可以优化速度（时间上比纯暴力快了一半）
     -   时间复杂度为O(kn)
3.   暴力-使用分治合并优化
     -   两两链表合并，最终归一
     -   尽管合并次数相同，但是由于每层的合并操作中，链表节点数量并不是相等的，随着链表数量的减少，链表节点数量增加，从而优化了速度
     -   仅在此思路中令n为链表最长的节点数量，时间复杂度为O($\sum_{i=1}^\infin\frac{k}{2^i}\times2^in$) = O(kn×logk)，与思路四是同等时间复杂度的。而由于需要使用递归，因此空间复杂度为O(logk)
4.   使用优先队列
     -   k是可以优化的，因为每次获取第n个数时都需要从k个链表头中查找，然后需要找到其中val最小的，并更改某一个链表头指向下一位。因此想到使用优先队列来维护这k个链表头
     -   删除和插入的时间复杂度为O(logk)，故时间复杂度为O(n×logk)，空间复杂度为O(k)

-   思考
    -   指向数组的引用同样是复制。所以要么直接对着数组操作，要么直接不依赖数组获取值



##### #25 k个一组翻转链表

1.   链表
     -   其实这题思路并不难，难在细节上。只需要记得当前需要做什么就好

-   思考
    -   字节的面试对这题要求是20分钟内能够完成
    -   第二次做这道题，用了35分钟，中间遇到bug但是自己验证过后又觉得没有错，在vsc上debug后发现是自己变量名写错了
    -   这次题目给自己在减少时间开销上还是带来了启发的
        -   如果存在需要实时维护的变量可以通过另一个变量得到，那么考虑是否不需要这个变量以减少维护
        -   如果确定这个变量不需要被维护，那么让它存在可以简化问题
        -   使用函数以降低整体复杂度
        -   没有从大局上进行思考：使用函数后，显然需要对翻转后的链表重新连接到原来的链表中。因为没有做到这种层次上的思考，所以走了弯路



##### #28 实现strStr()

1.   暴力 
2.   KMP算法



##### #29 两数相除

1.   二分查找
     -   变态



##### #30 串联所有单词的子串

1.   滑动窗口暴力
     -   显然题目要求的子串有固定的长度，因此使用滑动窗口对每个子串都进行一次匹配
     -   匹配方式似乎只能直接dfs，所以超时
2.   滑动窗口匹配
     -   暴力法没能够用到字符串连贯的特性，所以超时，所以需要做的事是边滑动窗口边匹配。但是对于单词，滑动窗口只滑动一个字符会使得之后原来中间的单词也失去了意义
     -   注意到题目提到每个单词的长度是固定的，所以可以每次滑动一个单词的长度。同时从0到第一个单词的长度-1开始设置窗口使得能够保证不会漏
     -   此时，这道题等同于之前做过的字母匹配

-   未通过
    -   各种溢出
-   思考
    -   读题不细，没有看到单词长度一样
    -   一开始也想不到利用字符串连贯性的方法

##### #31 下一个排列
- 未通过
	- 漏了“等于”的情况
- 思考
	- 我观察到了需要交换的两个值应该怎么找到，但是没有观察到两侧值都会呈现部分有序，因此没能够加以利用，而是使用了PriorityQueue完成


##### #32 最长有效括号

1.   动态规划
     -   因为有效的子串总是以')'结尾，因此不关心以'('结尾的子串的长度
     -   对于以')'结尾的子串会有两种形式，一种是`...()`，而另一种是`...))`。对于这两种形式，显然前者的长度总是上一个括号序列的长度+2，而后者则需要确认是否是`(内部最长序列)`这种形式后，再+2并加上上一个括号序列的长度。
     -   时间复杂度为O(n)，空间复杂度为O(n)
2.   栈
     -   最大值每次都在遇到')'时，弹出栈顶元素，通过比较两者之间距离而产生
     -   时间复杂度为O(n)，空间复杂度为O(n)
3.   贪心
     -   使用两个计数器left和right，统计路径上遇到的左右括号
     -   从左往右遍历，若left==right，则计算当前有效字符串的长度，当right>left时，则将两者同时置0
     -   这时仍漏掉了一种情况，即left>right时如`(()`无法求其长度
     -   因此从右也往左遍历一次，规则与上述相反
     -   时间复杂度为O(n)，空间复杂度为O(1)

-   思考
    -   这题的动态规划并不是常规的把每个元素作为状态，而是将一对完整的括号作为状态，因此在使用动态规划前，还需要先判断这是否是一种状态
    -   将完整的括号视为一种状态，并且不以计数器的方式求得上一个左括号的位置，而是通过动态规划内部完成位置判断。“找到其对于的左括号”看起来有很多种方法，但一定是通过自身机制的方法是最优的
    -   对栈的使用还停留在入栈出栈的情形判断，忽略了可以通过栈元素获取的值进行运算带来的解
    -   如果希望使用贪心算法，则应该对题目、题解形式有很直面的观察，能够用简单的方式去描述它们



##### #33 搜索旋转排序数组

1. 暴力。此题耗时不长
2. 半二分查找
    -   先找到数组真正的起点，然后判断target应该位于哪一个区间
    -   在对应区间中使用二分查找
3. 二分查找 优化
    -   在数组中随机找一个位置，这个位置的左右侧总有一方是有序的，因此，总是可以判断target位于哪一个区间，所以直接使用二分查找



##### #34 在排列数组中查找元素的第一个和最后一个位置

> 二分查找

- 思路
  1. 我的做法是通过二分查找找到target，然后从该位置扩散找到起始位和终点位。时间复杂度为O(logN+m)，m是值为target的数量
  2. 答案做法是分别使用二分查找找到起始位和终点。



##### #35 搜索插入位置

> 双指针-二分查找

- 思路
  1. 因为数组元素有序，所以使用二分查找


##### #39 组合总和

1.   回溯
     -   为了保证组合结果不重复，则货币的使用必须按照一定的顺序。首先准备了一个空列表，并尝试往列表中添加元素
     -   每次回溯到节点时，可以选择添加当前元素或者不添加而切换到下一元素，这样保证了顺序
2.   动态规划
     -   该题与#322类似，只不过该题需要得到组合的内容，而#322只需要得到组合的数量。可以使用新的序列来记录



##### #40 组合总和Ⅱ

1.   回溯
     -   数组中有重复的元素，而数组中每个元素使用次数也只有一次，因此想到使用哈希表记录它们之间的关系
     -   在dfs过程中，因为使用次数不可控，所以直接进行了不同次数使用该元素的dfs
     -   为了方便使用哈希表，这里使用了`List<int[]>` 



##### #42 接雨水

1.  使用贪心算法（暴力）
    -   记录下遍历过程中的最大值，当遍历过程中出现前一位比当前位小时，统计能够装多少水
2.  贪心优化：使用栈
3.  使用动态规划
    -   对于下标i，下雨后能到达的最大高度取决于其左右两侧的最大高度的最小值。于是使用两个数组以存储左侧最大高度和右侧最大高度，然后遍历得到当前位置的高度最小值并统计起来。此算法使得时间复杂度降为O(n)
4.  使用双指针优化动态规划。注意到下标i处能接的雨水由左侧最大高度数组和右侧最大高度数组决定，因此可以使用双指针和两个变量代替

- 思考
	- 双指针的做法和#11一样。因为左侧最大数组和右侧数组都能够呈现从某一角度呈单调递增状态，所以能够考虑优化


##### #43 字符串相乘
- 思考
	- 即使不是第一次做，但还是超时严重。首先是存在畏手畏脚的毛病，其次是有很多的小问题，包括Queue没有添加到List中，前置0的预防


##### #45 跳跃游戏Ⅱ

1. 动态规划
    -   遍历数组，使用新的数组用以记录到达该位置的最小值，在遍历过程中把能够到达的index填入步数，直到找到最后一位。
2. 贪心
    -   上述思路混淆了“可以跳跃”和“跳跃至”的概念。可以跳跃意味着选择更多，可以跳跃得越远绝对是越好的。
    -   通过观察思路1的dp数组，可以发现随着遍历元素越多，步数总是会随之不断增加或不变
    -   使用变量max不断维护该位置及之前最远能够到达的位置，使用变量currMax记录当前步数下，所能够到达的最远位置。只有当前位置等于currMax时，才需要更新该值



##### #46 全排列

- 提示
  - 全排列的交换应该包括自己与自己交换
  - 可以将数组转换成list来操作，以方便结果的添加；以及可以使用`Collections.swap()`方法来交换元素位置



##### #47 全排列Ⅱ

1.   全排列 哈希表
1.   全排列 添加前排重
     -   与曾经熟悉的#46全排列算法不同，通过添加数组元素到列表的方式去理解排列行为，并使用boolean数组记录是否已使用，这种做法更清楚地排除重复元素



##### #48 旋转图像

>   数组

-   思路
    1.  想要通过`.clone()`方法来克隆数组，但是因为是二维数组，所以终究新数组的变动会导致旧数组的变动。应该对每个元素都遍历一遍的方式来复制
    2.  旋转可以看作是四个小长方形的旋转，因此只需遍历其中一个小长方形并对小长方形内的每个元素都进行一次旋转即可
    3.  数组可以先经过水平轴翻转，然后再经过主对角线翻转以获得结果



##### #49 字母的异位词分组

1.   排序
     -   对每个字符串拆成char数组后排序，然后重新生成字符串并加入哈希表中

-   注意
    -   字符串数组的哈希值会随位置变化，但Java字符串不会。所以添加字符串时
        -   不可以写`ca.toString()`
        -   应该写`new String(ca)`



##### #55 跳跃游戏

> 贪心

- 思路
  1. 从最后一位向前推测所能到达的位置是否包含0。该思路混淆了“可以跳跃”和“跳跃至”的概念。未尝试
  2. 从第一位开始遍历数组，不断探索每一个下标其能够到达的最远位置。若当前下标已经不可到达，则跳过该下标。时间复杂度优化为O(n)



##### #56 合并区间:star:

> 数组

- 思路
  1. 使用排序将区间解决了分组的问题。只要当前区间的左边界大于答案区间的右边界，即需要创建新分组。
- 提示
  - 要做的是解决问题，而不是考虑通用性
  - 如果不能够一眼望近地解决问题，则应该考虑使用线性方式，按顺序来解决问题。使用排序，使得看待问题的角度发生变化
  - 先解决了答案区间何时创建的问题，再解决答案区间内容的问题



##### #62 不同路径

1.   动态规划：这是二维的#70爬楼梯
2.   组合数学：这也是组合的基础题，向右n-1步，向下有m-1步，得到$C_{m+n-2}^{m-1}$，使用循环计算得到结果

-   提示

    -   组合公式

        $A^m_n = \frac{n!}{(n-m)!}$ 

        $C^m_n=\frac{A^m_n}{m!}=\frac{n!}{m!(n-m)!}$ 


##### #63 不同路径Ⅱ
1. dfs【超时】
2. 动态规划
- 思考
	- 这道题很容易得到动态规划表达式，之前做出来是因为这道题被列在了动态规划专题里面了，所以知道用动态规划，而现在则是首先想到了dfs
	- 想到dfs没有问题，只是当遇到超时的时候开始自我怀疑了，没有想过题意在诱导我使用动态规划


##### #74 搜索二维矩阵

1.   二分查找
     -   先对行查找，再对列查找
2.   二分查找优化
     -   通过映射的方式，将矩阵看作是一个大的一维数组，然后使用二分查找

- 注意

  - 如果mid出现了指针不移位导致的死循环，可以如下处理

    `int mid = (left+right+1)/2; `



##### #75 颜色分类

> 排序

- 思路
  1. 直接使用`Arrays.sort()`
  2. 记录下所有数字出现次数，然后重新填充
  3. 因为题目数组只有3个数字，所以可以使用两个指针，将0移到前面，2移到后面



##### #76 最小覆盖子串

-   未通过

    -   以非t中字符串开头的字符串s。在覆盖这一步中未处理
    -   s比t短

    ```
    s = "ab", t = "b"
    s = "a", t = "aa"
    ```

-   思考

    -   很难不开始对自己多次的提交错误进行反思。有时会想是不是力扣给了太多测试示例，搞得自己都不会分清楚特殊情况了
    -   在处理错误的过程中耗时了1个多钟，多少都会打击到自己



##### #77 组合

> 排列

- 提示

  - 添加新的数组队列应该如下

  ```java
  ans.add(new ArrayList<>(list));
  ```



##### #78 子集

1.   全排列+筛选

     -   若上一位的值比当前值小（或是第一位），则不对当前顺序进行dfs

2.   标准的子集写法

     ```java
     public void dfs(int cur, int[] nums) {
         if (cur == nums.length) {
             ans.add(new ArrayList<Integer>(t));
             System.out.println(t);
             return;
         }
         t.add(nums[cur]);
         dfs(cur + 1, nums);
         t.remove(t.size() - 1);
         dfs(cur + 1, nums);
     }
     ```

3.   枚举

     -   因为元素不重复，则子集数量必定是2^n^-1个，且发现可用其二进制形式表示第i位元素是否在队列中（000>0, 101>5, ... ,111>8）
     -   该方法需要了解二进制运算

     ```java
     for (int i = 0; i < n; ++i) {
         if ((mask & (1 << i)) != 0) {
             t.add(nums[i]);
         }
     }
     ```


##### #81 搜索旋转排序数组Ⅱ
1. 递归
2. 首尾缩减
- 未通过
	- 将二分使用递归的形式表述时漏了left<right的判断
- 思考
	- 因为数组中存在重复的元素，所以使用递归可以在遇到无法确定哪一部分有序的情况下两边都进行搜索
	- 首尾缩减同样是为了应对这种特殊情况


##### #82 删除排序链表中的重复元素Ⅱ

> 链表

- 思路
  1. 一次遍历。要注意判断是否为空节点
- 提示
  - 只要找到解题顺序，问题就能解



##### #84 柱状图中最大的矩形:star: 

1.   暴力
     -   `s=h*l`，这是面积公式，所以有两种方式可以得到最佳的答案
     -   从宽入手，从当前位置开始与所有的位置比较一遍，得到最优解
     -   从高入手，从当前位置向左右遍历，找到以当前位置高度为基准的所有矩形，得到最优解
     -   注意，尽管两个方向的做法并不一样，但它们都是先按顺序对每一个元素进行遍历，再对每一个元素进行处理，不断确定矩形的左右边界在哪里
2.   单调栈
     -   上述两种暴力方式时间复杂度均为O(N^2^)，会超出时间限制，所以必须进行优化。因为枚举宽的方法使用了两重循环不易优化，因此考虑优化枚举高的方法
     -   对于枚举，设当前为第i根柱子，其高为h，自然希望其左右边界能够越来越长。阻碍其边界边长的因素是左右两侧高度小于h的柱子。于是想到尝试维护从当前位置i左右遍历边界时，左右侧可能作为答案的数据结构
     -   对这个数据结构而言，假如出现了两根柱子j0、j1，如果j0<j1且heights[j0]>heights[j1]，即j1会挡住j0，j0不会作为答案。因此最终维护的数据结构中，所有值总是递增或不变的
     -   因此在这个数据结构中，遇到更小的值时，就将该位置之前比该值要大的值都移走。显然，这是个栈结构
     -   维护上述栈的结果是最终将左边界的答案存储在一个数组中。对于右边界数组，只需反向操作一波即可
3.   单调栈的优化
     -   对于栈元素的出栈操作时遍历到的元素i，刚好也是其右边界。因此可以做到一次遍历即可

-   思考
    -   对栈的利用：栈始终保持单调递增的顺序，入栈作为左边界-1，出栈作为右边界+1



##### #85 最大矩形:star: 

1.   归一+单调栈
     -   对于找到最大矩形的操作，需要同时确认其长度和宽度，而且对于一个二维的矩形，似乎从何入手开始遍历都是一个头痛的问题
     -   所以想到了归一处理，听起来很不可思议，因为对于一维会丢失矩形信息
     -   这里的一维指的是仅按照从左到右等的单一顺序进行遍历，而不是把矩形拍扁了。当我们从一维的角度去看这个矩形，发现和上一题#84是一样的
     -   所以只需要先找到对于所有位置的柱高，然后再进行单调栈处理即可
     -   时间复杂度和空间复杂度都达到了惊人的O(n)，n指矩形面积




##### #88 合并两个有序数组

> 数组

- 思路
  1. 先合并后排序
  2. 因为数组nums1[]的后半部分为空，因此可以从后往前排序



##### #90 子集Ⅱ:star: 



##### #91 解码方法

1.  动态规划
    -   这是一道#77爬楼梯的增强版，在踏上这片楼梯之前，还需要先判断以下这片楼梯是否能够踏足。

-   思考
    -   仅求解可能方式的数量，要想到动态规划



##### #94 二叉树的中序遍历



##### #96 不同的二叉搜索树

1.  动态规划
    -   给定一个有序数列1..n，为了构建出一棵2二叉搜索树，可以遍历每个数字，并将该数字作为树根，将其左侧作为左子树，右侧作为右子树
    -   由于根的值不同，因此能保证每棵二叉搜索树是唯一的
    -   接着再按照同样的方法递归构造左子树和右子树。由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用，因此想到使用动态规划来求解本题
    -   定义G(n)为长度为n的序列能构造成的不同二叉搜索树的个数，F(i,n)是以i为根，序列长度为n的不同二叉搜索树的个数
    -   显然有如下式子：$G(n) = ∑_{i=1}^n(F(i,n))$ ，边界情况有`G(0)=1 G(1)=1`
    -   对于F(i,n)，则有如下公式`F(i,n) = G(i-1)*G(n-i)`
    -   因此只需要计算G(n)即可


##### #97 交错字符串
1. 动态规划
	- 因为s3从头到中间的某一段总是由s1和s2从头到中间的某一段组成，所以通过枚举s1和s2的所有长度最终找到结果
- 思考
	- 想到需要通过枚举的方法解决问题，但是想不出怎么使用动态规划
	- 想着使用递归，但是写不出


## 1+

##### #101 对称二叉树

> 树

- 思路
  1. bfs，对每一层进行一次对称检查。要注意不能漏掉值为null的节点，否则会产生伪对称的现象
  2. 通过同步移动两个指针来遍历这棵树：指针p右移时，q左移；指针p左移时，q右移，若两者值不相同则不对称



##### #103 二叉树的锯齿形层序遍历

1.   BFS
     -   与其最后翻转链表，不如每次添加时都添加到头部



##### #105 从前序与中序遍历序列构造二叉树:star: 

1.   递归
     -   试着把每次递归都看作是填充根节点

-   思路
    -   前序遍历：[root, [左树], [右树]]
    -   中序遍历：[[左树], root, [右树]]
    -   递归没做出来的原因：没能找到递归的理由



##### #108 将有序数组转换为二叉搜索树

1.   递归
     -   平衡的二叉搜索树有很多种形式，只需要符合平衡要求即可
     -   要做到平衡，只需确保树的左右端点节点总是一样多，使用二分查找可以解决这个问题



##### #109 有序链表转换二叉树

1.   快慢指针+分治
     -   对于链表转二叉平衡树，显然链表中间是根节点，根节点两侧链表组成子树
     -   中间节点可以通过快慢指针找到，而通过分治的做法不断提取根节点并填充其左右节点
2.   中序遍历
     -   显然，链表是中序遍历的结果，所以这道题变成了从中序遍历构建二叉树
     -   中序遍历需要用到左右指针表示范围，使得提供准确指示左右子树的能力。使用对象内的全局遍历指代当前链表顺序遍历到的第n个值，并提供给中序遍历到的节点

-   思考
    -   恭喜自己做到了方法1
    -   方法2实在太妙了，值得一提。一开始想过方法2但是无从下手



##### #110 平衡二叉树

1.   BFS 失败
     -   因为题目提到了平衡二叉树的定义是每颗子树的高度差绝对值都不能超过1，使用BFS不能体现出“每颗”
2.   DFS
     -   遍历树，并对每个节点都获取其左右节点的以检查其是否平衡，并获取左右子树是否平衡
     -   显然，求高度需要遍历树，求平衡也需要遍历树，使得时间复杂度较高
     -   时间复杂度为O(n^2^)，空间复杂度为O(n)
3.   DFS 后序遍历
     -   将平衡结果体现在返回的高度中，若不平衡，则返回-1
     -   时间复杂度为O(n)

-   思路
    -   明明只需一步就可以降低时间复杂度了，但是困惑于如何体现其不平衡。这里的做法是返回一个不正常的值



##### #113 克隆图

1.   DFS
     -   使用HashMap进行查重，若已经遍历过该节点，则返回节点对应的克隆节点，即map的value



##### #115 不同的子序列

1.   动态规划
     -   令dp(i,j)中的i为字符串s的第i个字符起，存在着字符串t的第j个字符起的子序列，从而得到状态转移方程

-   思考
    -   没有想到动态规划实现的方法是因为总是想着全局的方向去解决问题，没有看到状态转移的细微变化，想不到每个状态代表着什么
    -   要思考状态转移，更需要先思考状态转移的终点、起点，才能得到状态转移表



##### #116 填充每个节点的下一个右侧节点

> 广度优先遍历

- 思路

  1. 写出算法即可

- 提示

  - 使用队列

  ```
  Queue<Node> queue = new LinkedList<Node>();
  ```

  - 获取下一个队列元素：peek()



##### #117 填充每个节点的下一个右侧节点指针 II

1. BFS
2. BFS优化
    -   既然每一层都可以通过next看作是链表，那么就可以不使用队列，而是通过链表的遍历来完成
    -   将已经形成了链表的层称为第i层，通过遍历第i层，为第i+1层以使用next的方式建立链表
    -   空间复杂度优化为O(1)

-   思考
    -   如果题目要求更改结构，则可以思考已经变更的结构是否能够为我所用



##### #119 杨辉三角Ⅱ

>   数组

-   思路

    1.  直接递推，使用二维数组记录整个三角。由于每一行只需要用到上一个数组，所以可以优化为只使用两个数组

    2.  优化为O(n)：递推式$C^i_n=C^i_{n-1}+C^{i-1}_{n-1}$表明，当前行第 i 项的计算只与上一行第i−1项及第i项有关。因此我们可以倒着计算当前行.




##### #120 三角形最小路径和

> 动态规划

- 思路
  1. `f[i][j]=min(f[i−1][j−1],f[i−1][j])+c[i][j]`
  2. 使用该动态转移方程，对三角形底部最后一行的每一个元素查找一次最小值，并使用二维数组记录每一个位置的最小路径。由于路径值可能为0，所以需要使用额外的bool二维数组记录是否访问过。
  3. 上述过程可以进行优化。从每一层遍历得到最小路径结果并记录在二维数组中，从上到下遍历每一层，这样就不需要使用bool二维数组记录是否访问过该位置
  4. 空间复杂度优化至O(n)：仅使用一维数组，记录每上一行的数据



##### #125 有效的回文

-   未通过
    -   没留意到题目说数字也算
    -   `left<=right`有处理，但没处理好。没有解决回文串之间是无关字符时的情况



##### #129 从根节点到叶子节点的路径数字之和

-   未通过
    -   错把后序遍历root.right==null的情形当作叶子节点了



##### #130 被围绕的区域

1.   BFS 超时
     -   从边界入手标记O点，然后进行一次BFS，最后重新遍历一次表格，把未被标记的O点改为X
2.   BFS 优化
     -   从边界搜索时只将对应位置加入队列中，在最后遍历表格之前才进行BFS，这样只需要一次BFS即可

##### #131 分割回文串
- 不会做

##### #132 分割回文串 Ⅱ
- 不会做

##### #136 只出现一次的数字

> 位运算

- 思路
  1. 通过异或运算找到唯一的数字`single^=i;`



##### #137 只出现一次的数字Ⅱ

1.   排序
     -   为了实现不使用额外空间的目标，所以最终使用了先排序在筛选的方法
2.   位运算
     -   这题没法像#136一样直接用异或运算，因为其他元素都会出现3次
     -   考虑到使用求余的方式找出唯一的元素，但由于有可能该元素也能够被3整除，所以不能直接这么做，应该在二进制下进行除以3求余
     -   这里对每一位数进行单独的qiu和统计，然后再除以3。因为二进制最多有32个位，所以要统计32次
3.   位运算优化
     -   方法二的每位单独统计使得性能不高。所以思考有没有可能能够一次统计得到结果
     -   将每一位都用来记录余数，把每一位都当作三进制数来统计，当前位为1则加，当值为3时归0。在二进制数中自然无法做到，所以使用两个数a、b来做记录，第一个数a记录3进制的低位，第二个数b记录3进制的高位。当然，记录余数的结果最终都只有0和1
     -   最终得到关于新a、新b的真值表，并根据得到的电路完成代码设计
4.   位运算优化2
     -   方法3的电路设计中，a的运算较复杂，所以先考虑计算b，再计算a



##### #138 复制带随机指针得链表

1.   哈希表：顺序
     -   遍历两次链表，第一次将链表的next指针复制，第二次则将random指针复制，通过使用哈希表和数组使得复制的random值一一对应
2.   哈希表：DSF
     -   不断填充next指针和random指针，并将源和复制结果作为键和值保存在哈希表中
     -   当发现哈希表中无此值时，则填充此值
3.   优化
     -   事实上，新老链表都保持着一样的链状的形式，所以想到了先复制得到新节点，让新老节点之间保持联系，然后完成random指针的复制，最后才完成next指针的复制，形成新链表的链状形式后断开联系
     -   令A、B、C为老节点，而A‘、B’、C‘则为复制后的节点。将ABC的next指针分别指向A’B‘C’。为了保持老链表的链状关系，所以A‘B’C‘的next指针需要指向老节点的next指针。最后链表以AA’BB‘CC’的形式呈现
     -   将ABC的random指针复制到A‘B’C‘，然后将A’B‘C’的next指针指向真正的下一位

-   思考
    -   找到重复的地方，并思考能否优化



##### #139 单词拆分

>   动态规划

-   思路
    1.  通过递归的方式，找到一个位置能够放一个单词后，接着找下一个。遗憾的是超时了
    2.  优化时间：将列表转哈希表，然后使用数组记录当前位置是否可到达，以减少思路1如同树形结构般，每次都要从头开始遍历。时间复杂度同样是O(n^2^)，但是更快速。写出动态规划转移方程：`dp[i]=dp[j] && check(s[j..i−1])`。
-   技巧
    -   尽管使用char[]比charAt()更快速，但是new String(Arrays.copyOfRange(ca))比string.substring()要慢很多



##### #142 环型列表Ⅱ

1.   哈希表
2.   快慢指针
     -   需通过数学证明为何会在第一圈内相遇



##### #146 LRU最近最少使用缓存

1.   哈希表与双链表
     -   使用链表维护最近使用顺序，链表逻辑应该自己实现
2.   优化 使用数组代替哈希表



##### #152 乘积的最大子数组

>   动态规划

-   思路
    1.  显然，数组中只有0和负数会干扰乘积的最大，若只有正数的话，只需一直相乘就找到最大值了。解题的思路是动态规划，不断遍历，把第i个元素作为最大子数组的结尾，若遇到第一个负数，则记录负数前的乘积为before，若遇到第偶数个负数，则所有一起相乘，若遇到第奇数个负数，则除以若遇到0，则当做重新开始。这个思路体现了动态规划的思想，f(i)是结尾包括i的子数组的最大值，但是完全依靠着常识得出的结论，于是代码逻辑写得较乱，思考时间较长，但是其空间复杂度仅为O(1)
    2.  $f_{max}(i) = max^{n}_{i=1}\left[f_{max}(i-1)*a_i, f_{min}(i-1)*a_i,a_i\right]$ ,$f_{min}(i) = min^{n}_{i=1}\left[f_{max}(i-1)*a_i, f_{min}(i-1)*a_i,a_i\right]$ 。上述是该题的动态规划方程，并不拘泥于知道数据中遇到了多少个负数，而是把正值最大和负值绝对值最大共同遍历维护从而得到结果，简化了计算过程。需要思考到，如果动态规划涉及到了状态有可能不断变更，则不如两种状态一起遍历



##### #153 寻找旋转数组中的最小值

> 二分查找

- 思路
  1. 不断遍历数组，直到数组中出现小于数组最后一位值得数字。时间复杂度为O(n)
  2. 使用二分查找
- 提示
  - 一开始想到使用双指针往中间，但是会出现因为数组元素数量为单双数时需要分类讨论，没成功。需要分类讨论的解决方法容易出错。
  - 有序数组的范围锁定一定要想到使用二分查找



##### #155 最小栈

1.   暴力
2.   利用栈的特性
     -   使用了额外的栈，其栈顶是原来的栈在不同操作后的最小值。时间复杂度优化为O(1)



##### #160 相交链表

1.   哈希表暴力
2.   双指针
     -   想方设法让两个指针相遇在第一个相交的节点
     -   令链表1的不相交节点数为a，链表2的不相交节点数为b，相交节点数为c
     -   假若a==b，则还没遍历完链表就能够捉刀相遇
     -   假若a!=b，则当任意指针走到终点，则从对方链表开始遍历。因为a+c+b == b+c+a，因此终究会相遇



##### #162 寻找峰值

-   思考
    -   在趋势图中也可以使用二分查找


##### #179 最大数
- 未通过
	- 没有判断前导0


##### #187 重复的DNA序列

1.   哈希表
     -   使用两个哈希表，一个是为了了解当前子字符串是否重复出现了，另一个是为了防止往答案列表重复添加



##### #188 买卖股票的最佳时机
-   未通过
    -   没留意k可能为0，数组长度也可能为0



##### #189 旋转数组

> 数组、分析

- 思路

  1. 使用新的数组，直接求余拷贝

  2. 每次执行一次向右移动，执行n次。虽然容易理解，但性能不佳

  3. 环状替换：和方法1不同，只是暂时地保存被替换的元素到temp中。通过计算得知会有gcd(k,n)轮的循环，每轮循环中每个元素不断与后k位交换

  4. 基于以下事实：当数组元素向右移动n次后，尾部会有k mod n个元素移动至头部，其余元素则向后移动k mod n个位置。通过观察，可以发现旋转结果可以通过三次反转实现，只需要自己写一个翻转方法即可

     ```java
     nums = "----->-->"; k =3
     result = "-->----->";
     
     reverse "----->-->" we can get "<--<-----"
     reverse "<--" we can get "--><-----"
     reverse "<-----" we can get "-->----->"
     this visualization help me figure it out :)
     ```



##### #190 颠倒二进制位
- 思路
  1. 通过位运算使得不需要拆散int为每一个数字，直接修改



##### #191 位1的个数

> 位运算

- 思路
  1. 将数字转为二进制形式的字符串，然后遍历'1'的个数
  2. 可以不转换为字符串，而是通过位运算逐步检查
  3. 可以利用位运算技巧（#231）不断清除最低位0



##### #198 打家劫舍:star: 

> 动态规划

- 思路
  1. 只要找到动态规划方程，问题就可以迎刃而解。方程的左侧是答案，右侧是解法。


## 2+

##### #204 计算质数

1.   暴力
     -   每个数n都尝试除以\[2, min{sqrt(2)+1, n})范围内的数字，若没有出现余数为0的情况，则认为这是质数
2.   埃氏筛
     -   显然，如果x是质数，则2x不是质数，3x不是质数，以此类推
     -   因此，每找到一个质数时，都把那些不是质数的数标记出来
     -   因此，在题目开始前，需要假设每个数都是质数
3.   线性筛
     -   对每个数字都进行一次标记处理，但是标记过程是将当前数字与所有已经找到了的质数相乘


##### #205 同构字符串
- 未通过
	- 理解错题意，以为是可以存在相同映射

##### #207 课程表

1.   dfs/拓扑
     -   并不直接遍历，而是通过统计图的入度来处理
     -   不断将入度为0的节点在图中删除并加入队列中，找到指向的节点，重新统计一次入度。然后进行同样的操作，直到最后找不到入度为0的节点，再判断图中是否还有节点


-   思考
    -   通过处理入度解决了判断课程是否仍有需要先修的课程



##### #209 长度最小的子数组

1.   双指针 同713
2.   前缀和+二分查找



##### #220 存在重复元素

1.   TreeSet
     -   因为既需要维护数据间的顺序，又需要移除数据，还需要提取某个区间段的数字，所以使用了HashSet
2.   桶排序
     -   设定桶的大小为t+1，如果两个元素同属一个桶，则必然符合条件；如果属于相邻的两个桶，则判断两者差是否不超过t；否则必然不符合条件
     -   因为桶内最多只会有1个元素（否则必定符合），所以使用哈希表实现桶，键是指向桶的id，值是元素
     -   桶排序体现的是降维的思想

-   技巧
    -   TreeSet获取比某值要大的数：`set.ceiling(E e)` 



##### #221 最大正方形

1.  暴力与动态规划

    -   设每个遍历坐标matrix\[i][j]为正方形的右下角，并使用dp数组记录该位置的最大正方形
    -   若该值不为1，则必然不是正方形
    -   若该值为1，则通过dp\[i-1][j-1]获取其边长pa，故设当前位置边长a=pa+1，然后确认dp\[i-a..i][j]以及dp\[i][j-a..j]所有位置是否都为1，若是，则将边长a计入dp数组中，否则将边长a减小后重新遍历，直到找到符合的值

2.  动态规划

    -   既然想通过动态规划解决问题，那么可以考虑有没有无需遍历的方式，所以联想到了当前位置的上侧和左侧。

    -   发现关系：

        ```
        f[i][j - 1] >= f[i][j] - 1
        f[i - 1][j] >= f[i][j] - 1
        f[i - 1][j - 1] >= f[i][j] - 1
        ```

        将这三个不等式联立后，得到

        `f[i][j] ≤ min{f[i-1][j],f[i][j-1],f[i-1][j-1]}+1`

    -   得到该方程式后，将不再需要使用暴力解法



##### #226 翻转二叉树

> 二叉树

- 思路
  1. 使用递归对其左右借点进行交换
- 提示
  - 没能够做出来是因为忽略了这是节点的切换而不是数值的切换的事实，所以觉得无法使用递归



##### #230 二叉搜索树中第k小的元素

1.   映射后排序
     -   通过dfs将树映射成链表的形式，排序后取地k个值
     -   这种做法显然没有利用到搜索树的性质
2.   中序遍历
     -   对于二叉搜索树，其中序遍历后的结果就是有序的。因此只需要找到第k个值就可以返回



##### #231 2的幂

> 位运算

- 思路

  1. 通过递归不断除以2来判断。若除以2有余数则返回false。注意0要分类讨论
  2. 使用如下二进制运算技巧
  3. 只需要判断n是否位2^30^的约数同样可以

- 技巧

  - `n & (n - 1)`：清除最低位的1。若其值为0，则是2的幂

  - `n & (-n)`：直接获取二进制表示的最低位的 1。若其值与n相等，则是2的幂

  - 部分语言中，位运算优先级可能较低，需要注意运算顺序
    - java中，与运算是`&` 



##### #234 回文链表

1.   递归/栈
     -   使用递归进行反转。遍历到链表尾部后往前比较
2.   反转链表
     -   为了不更改链表结构，可以完成处理后把链表重新反转



##### #236 二叉树的最近公共祖先

1.   中序遍历
     -   因为树不是可以直观处理的数据结构，所以想到映射后处理。
     -   因为中序遍历能够反映左右子树，因此想到了先获取树的中序遍历的数组，再使用双指针完成题解
     -   最初的做法超时了，因为中序遍历中获取每颗子树的index都需要遍历一次数组，所以后来改用哈希表存储数据后成功了
     -   超过40分钟了啊！
2.   哈希表
     -   使用map记录每个节点的父节点，然后从p和q同时向上移动并将位置信息记录在set中
     -   如果发现当前路径已在set中，则为公共祖先
3.   递归
     -   递归过程旨在找到最近的公共祖先，这个祖先的判断条件可以找到，最终发现其只需要判断当前节点的左右子树是否包括了p或者q即可，也不需要直到是确切哪一个
     -   使用递归是三种方法中唯一可以做到一次遍历的

-   思考
    -   想到映射自认为很不错，但是中序遍历的本质仍是在使用树结构，所以映射处理没必要
    -   总是觉得递归一定是最糟糕的，但这题反而递归是最佳做法
    -   首先应该思考从当前节点怎么判断，情况可以分为：最近公共祖先之上、之下



##### #238 除自身以外数组的乘积

-   思路
    1.  因为数组中存在0，所以没有办法通过除法得到数组。可以使用暴力为每个数字都遍历一遍乘积。为了优化暴力算法，将遍历时在元素i之前的乘积保存起来。因为想到i之后的乘积总会不断减少，所以没想到优化的方法了
    2.  通过从后往前遍历同样能够获得累计乘积，于是只需要两次遍历这个数组即可解决问题



##### #239 滑动窗口的最大值

1.   堆
     -   添加index而不是数值
     -   如果poll得到的index超出范围，那就继续poll，直到找到符合的数字

-   未通过
    -   使用了TreeSet，但是因为TreeSet不能添加重复元素所以产生错误
-   思考
    -   一开始想着要移除元素，但是优先队列没办法做到，所以用了TreeSet。但是发现如果数组中存在重复的数字，TreeSet就会都移除使得结果产生错误，又想着尝试TreeMap但因为超时打住了。看了官解才知道没必要立刻移除



##### #240 搜索二维矩阵Ⅱ

>   双指针

-   思路
    1.  因为矩阵从上到下有序，从左到右有序，但两个有序似乎不相干，所以遍历了矩阵的列，并对其每一行进行二分查找。时间复杂度是O(mlogn)，因为最多要进行m次二分查找
    2.  该思路利用了两个有序：期望从右下角开始以斜线的形式遍历矩阵。若当前值比target小，则右移；否则上移



##### #241 为运算表达式设计优先级

1.   按照顺序由前往后的遍历方式（未尝试）
     -   尽管整个运算表达式很复杂，但是始终有计算顺序，所以遍历每个运算符号并递归知道最后只有两个一个运算符
     -   但是这种方法没办法从源头上保证不重复，因此需要使用set来查重
2.   按照顺序由后往前的遍历方式
     -   令每一个符号作为最后的运算符号，使用列表保存该符号前后表达式能够产生的所有结果

-   思考
    -   在得到思路1之前，想到的遍历顺序是：对从左到右对每个符号做推测，按照“这个符号之后的表达式作为一个数字”和“这个符号只作为当前前后两个数的运算符”进行递归。这个思路在我对提供的例子进行模拟的时候发现漏了一些结果。在看完题解后觉得这个思路并没有顺着表达式的特点去做，所以即使是成功的，但也一定十分麻烦
    -   得到思路1时想到的一个从源头查重的方式是得到每个新的数字后，总是对这个数字的后面中选择下一个被计算的顺序，以达到从源头查重的目的。这个方法在只有3个数时是正确的，但是在更多数字的情况下却没办法说明是正确的。且思考完题解后觉得这一定是错的。
    -   这道题没有做出来，当然值得一提的是题解思路和思路1只是顺序反了。这给了我查重的思路



##### #254 因子的组合

1.   递归
     -   求出一个数的两个因子容易做，但是求出一堆因子则不容易做
     -   所以对每个因子进行一次递归求因子。为了保证不重复，需要保证保持顺序



##### #264 丑数

1.   暴力
     -   丑数是只包含质数2、3、5的数字，若当前数字除以2、3、5后，得到的数字应该也是丑数且被遍历过。于是使用哈希表记录遍历过的丑数，然后从1开始遍历，使用此方法判断是否为丑数，直到找到第n个丑数为止。该方法尽管时间复杂度为O(n)，但是实际上当数值变大后，丑数会越来越难遇到，故导致超时了
2.   最小堆
     -   与其不断遍历来寻找丑数，不如自己创造这些丑数。因为丑数只由2、3、5组成，因此可以通过丑数键的组合相乘找到结果
     -   但是组合过程中遇到了困难：如何组合，如何遍历直到得到结果为止，以及如何确保得到的结果确实是第n个丑数
     -   最小堆方法使用了堆PriorityQueue来保证数据顺序，使用了哈希表来查重。从堆中取出当前最小的元素x，并将2x、3x、5x检查是否没有重复，然后加入堆中。为了保证顺序是正确的，所以该过程直到堆中取出了第n个元素才算完成
     -   从堆中取出1个元素并加入3个元素的时间复杂度为O(4log_3n)=O(log_n)，因此总时间复杂度为O(n*log_n)
3.   动态规划
     -   最小堆的方法会预先存储较多的丑数，导致空间复杂度很高；维护最小堆的过程也导致时间复杂度很高，于是想到使用动态规划进行优化
     -   定义数组dp，其中dp[i]代表第i个丑数，有dp[1]=1
     -   维护三个指针p2，p3，p5指向的是当dp[p2]\*2，dp[p3]\*3，dp[p5]*5的值。当遍历到dp[i]时，dp[i]为这三者中找到最小的值。最终应该返回dp[n]



##### #269 火星词典

1.   拓扑bfs
     -   先构造pair，再连线



##### #283 移动零

> 双指针

- 思路
  1. 非零往前补，然后补零。统计了0的个数以确定需要移动多少位。但是过程中出现了溢出、连续为0的情况，没有处理好。且代码略复杂
  2. 应该忽略0的存在。左指针总是指向非零部分的结尾处，右指针不断检查下一位是否为零，需遍历整个数组。指针可以藏在循环里（这里右指针是以foreach形式展现的）



##### #285 二叉搜索树的中序后继

1.   中序遍历
     -   找到目标值后设置标志位为true，遍历时标志位为true则退出
2.   直接搜索
     -   注意到这是一棵二叉搜索树，所以甚至不需要遍历就能够找到目标值



##### #278 第一个错误的版本

> 双指针-二分查找

- 思路
  1. 因为答案在某一点处，且该点前后内容有区分度，所以使用二分查找。
- 技巧
  - 二分查找中，假设循环内经过比较后，出现了`left = mid`时，mid的计算应该为`int mid = (left+right+1)>>>1`，这样可以防止left\==mid时进入死循环。而出现`right = mid`时



##### #290 单词规律

-   思路
    1.  使用map判断是否单向映射，使用set排除重复映射


##### #295 数据流的中位数
1. 使用ArrayList维护数据，使用二分法找到插入位置
2. 使用两个优先队列来维护中位数
- 思考
	- 太久没做二分法了，写个二分法遇到了许许多多的挫折


## 3+

##### #300 最长递增子序列

1.  动态规划
    -   动态规划第一步要考虑的是如何将问题规模减小。对于数组有两种思路：规模每次减小一半、规模每次减小一个。简化问题的方式则是定义dp[i] 为考虑前i个元素，以第i个数字结尾的最长上升子序列的长度，且nums[i] 必须被选取，这样，不断遍历并记住最大值即可得到结果
1.  贪心
    -   贪心算法需要知道一次遍历的过程中，如何让被选中的值组成的序列最大。对于此题，显然遇到更大的值应该让其直接加入序列，遇到更小的值则考虑替换序列中恰好比它大的值。就像打麻将一样，用更好的值替换掉次好的值
    -   因为对于更小的值，需要考虑其加入队伍的位置，所以需要维护一个数组作为最长上升子序列



##### #303 区域和检索

1.  暴力
2.  一维前缀和
    -   因为暴力法需要多次遍历该数组，所以如果能够为数组进行预处理，使得求和过程能够尽可能地快就可以省下时间
    -   使用前缀和优化时间复杂度。预处理中，记录每个位置及之前的和，在求和过程中，有`sum(i,j) = f(j+1)-f(i)`



##### #304 二维区域和检索

1.   暴力
2.   一维前缀和
     -   这是#303的二维形式题目，可以通过把每一列看作是一个单位，使用一维前缀和得到结果
3.   二维前缀和
     -   使用二维前缀和优化一维前缀和。这里思考到了矩阵面积的相减：减去水平侧和垂直侧长方形，再加上减多了的小矩形



##### #305 岛屿数量

1.   并查集
     -   将二维数组的位置映射到一维数组上，然后进行并查集操作
     -   如果待操作区域是海，则将其祖先设为自己。然后检查上下左右的联通区域并连接起来
     -   每次操作结束后都需要检查一次岛屿数量，所以需要遍历一遍
2.   并查集优化
     -   将海设为岛屿后岛屿数量+1，祖先不相同的两个岛连接后祖先-1。因此没有完全遍历一遍数组的需要

-   未通过
    -   忘记了岛屿数量会因为合并而减少
    -   联通分量统计的方式有误



##### #309 最佳买卖股票时机含冷冻期

>   动态规划

-   思路
    1.  因为股票中暂时的决策可能会导致当前收益低但是最后收益高，所以应该使用多状态的动态规划。考虑到该题中，股票的购买有3种状态：持有中，冻结期，以及未购入，于是分三种状态进行动态规划即可



##### #310 最小高度树

1.   bfs/dfs
     -   通过数学证明得到图中最长路径必定会经过最小高度树的根节点，且最小根节点为该最长路径的中间。当路径长度为偶数时，有两个根节点，否则只有一个
     -   首先使用dfs/bfs从节点0找到距离最远的节点作为起点，然后再从该节点找到最远的节点，此时找到了最长路径。在遍历的同时，使用数组记录到达当前节点的上一个节点的位置，以方便下一步将路径记录到list中
     -   使用list记录其路径，此时可以直接得到根节点
2.   拓扑bfs
     -   首先需要用到上一题的数学证明
     -   不断将出度为0的节点删除，最后剩下1个或者两个节点的时候，就找到了根节点



##### #312 戳气球

1.   动态规划/自顶向下记忆化
     -   戳气球的操作，发现这会导致两个气球从不相邻变成相邻，使得后续操作难以处理。于是需要倒过来看这些操作，将全过程看作是每次添加一个气球
     -   新的气球加入后，再对气球左右两侧各进行这样的操作，显然，这需要dfs来完成
2.   动态规划/自底向上
     -   通过方法一的思路，知道了状态应该是什么样的。于是令dp(i,j)表示从填满区间i到j能得到最多的硬币数

-   思考
    -   对于【删除】这一操作，想不到如何使用状态来描述，因为好像也没办法用状态指定删除气球的先后顺序
    -   题解让我知道了如果删除使得困惑，可以倒过来试下添加。问题的入手一定要从简单到困难，从小到大
    -   最终的状态规划是二维的、用来表示下标区间而不是单个数字的最多硬币数



##### #318 最大单词长度乘积

1.   暴力+哈希表
     -   每两个单词之间进行一次比较
     -   每个单词的字母都先遍历一遍哈希表，以确认是否有重复
2.   位运算
     -   依然是每两个单词进行一次比较，但是为了提高运行速度，所以使用了位运算处理
     -   首先要对每个单词进行预处理，因为要着重点在于字母是否重复上，所以使用单词生成掩码默认为26位，使用或运算处理每个字母，若第i个字母出现了，则第i位为1。这是通过左移位符完成的
     -   最后使用与运算进行比较，若两个单词的掩码进行与运算后值为0，则没有重复的字母
3.   位运算优化
     -   使用哈希表记住所有的掩码值并作为键处理，然后使其值为最长的单词



##### #324 摆动排序Ⅱ

1.   排序

     -   令x=(n-1)/2，通过推理可得符合要求的数组连续相同的元素必须小于等于x个，所以可以令nums[i]与nums[i+x]放在一起。对于偶数个元素下，虽然无法说明nums[i+1]<nums[i+x]，但是能够说明nums[i-1]<nums[i+x]，因此首先得到一个以较大元素开头的数组

         ```
         nums[x], nums[0], nums[x+1],..., nums[n-1-x]
         ```

     -   反转后得到题目所需数组

         ```
         nums[n-1-x], ..., nums[x+1], nums[0], nums[x]
         ```

     -   对于奇数个元素下能够进一步举证得到连续相同的元素会小于x-1个，因此可以说明nums[i+1]<nums[i+x]，直接插入即可。因为此时反转后结果仍符合要求，因此不需要分开写

-   思考

    -   一开始靠猜测的方式写了代码，还猜了两次，浪费了时间。潜意识下依然没有更愿意去做证明工作

    -   后来自己推断是连续相同的元素必须小于n个，且这相同元素恰为n个时，元素必须全部在开头或者结尾，这个结论是通过手动尝试找到符合的数组却没能找到而下的。但后来遇到test case时才发现其实是存在符合的数组的

    -   证明方式不能靠经验

        

##### #326 3的幂
- 未通过
	- 当3=0时，除以多少次3都还是0。缺乏了对0的判断


##### #334 递增的三元子序列

>   贪心、动态规划

-   思路
    1.  暴力：3次遍历，得到从左开始的最小值、从右开始的最大值，以及最后一遍：遍历是否有同时符合的数
    2.  贪心1：考虑到一个递增的三元子序列数字递增，first总是遍历过程中的最小值，second只需要大于first即可，同时应该尽量地小，接着只要找到一个比second大的值即可，因此只需要一次遍历即可找到答案
    3.  此题是#300的简单版，所以使用动态规划和贪心都可以



##### #338 比特位计算

1.   使用Java内置函数`Integer.bitCount`可以直接获取二进制表示下1的数目
2.   Brian Kernighan算法
     -   对于任意整数x，令x = x&(x-1)，该运算将x的二进制表示的最后一个1变成0。对x重复该操作，直到x变为0，则操作次数则是x的一比特数
     -   时间复杂度O(nlogn)
3.   3种动态规划
     -   以下三种动态规划皆基于`x&(x-1)`可以去掉二进制表达下的最后一个0
     -   最高位式：`f(1001) = f(0001) + 1` 
     -   最低位式：`f(1001) = f(100) + 1001 & 1 `
         -   除以2的余数可以通过`&1`实现

     -   最低1位式：`f(1010) = f(1000) + 1` 
     -   时间复杂度O(n)


-   思考
    -   对于动态规划
        -   状态转移并不依赖迭代方式（迭代方式都是从1到n遍历），而是通过观察规律找到（找到了3种）
        -   状态总是从靠近状态源的方向种获得（总是从较小的状态获取）
    -   原本思考过不迭代数字，而是构造数字的方式完成填充。如果这种方法能够实现，则时间复杂度为O(n)。但是显然没有动态规划通过状态转移容易思考



##### #340 至多包含k个不同字符的最长子串

1.   滑动窗口+哈希
     -   使用哈希表记录字符出现的次数
     -   删除时，左指针右移且不断从哈希表中重新记录字符串出现次数，直到为0
2.   滑动窗口+哈希 优化
     -   使用哈希表记录字符最后出现的位置
     -   在O(1)的时间复杂度下完成删除工作

-   未通过
    -   在滑动窗口的优化中，对需要删除的字符判断有误。在”abaccc“中的后4位，显然不应该删除先出现的字符，而是最后出现的字符位置最小的那一个字符



##### #341 扁平化嵌套列表迭代器
- 未通过
	- 没有想到列表作为子元素时可以为空
1.   初始化阶段扁平元素
     - 初始化阶段不断寻找是否包括了迭代器
2. 边遍历边展开
	- 使用栈维护遍历过程




##### #344 反转字符串

> 双指针

- 思路：双指针往中间靠拢



##### #347 出现频率最高的k个数字

1.   哈希表与优先队列
     -   使用哈希表记录频率，使用优先队列进行排序

-   未通过
    -   在使用哈希表记录频率的时候同时用优先队列进行排序，导致了频率发生变化时，优先队列的元素无法进行更新



##### #351 安卓系统手势解锁

1.   回溯/bfs
     -   将每一个手势路径都记下来，使用的是一个数据类，包括了一个数组visited，以及最后到达的路径
     -   将所有路径信息记录到list中
     -   每一次增加点数后，不断遍历1-9，并将上一次的list加上所有合理的结果
2.   回溯优化：dfs
     -   因为不需要获得实际的路径，所以直接使用递归的形式进行遍历会更快
3.   回溯优化2
     -   因为九宫格是中心对称的，所以还有优化空间



##### #352 将数据流变为多个不相交区间

-   未通过
    -   涉及到了list的结构更改

1.   使用list维护
     -   因为没办法直接指定对应需要操作的区间，所以代码写得很乱，出现了各种的bug，场面一度失控
2.   优化：使用TreeMap

-   思考
    -   一方面自己思考问题确实更全面了，另一方面自己仍然会逃避从全面的角度来思考问题，所以才会导致像这题一样花了尽2个钟来调试bug的场景，最后也没做出来



##### #373 和最小的k个数对

1.   暴力堆
     -   将所有可能的配对入堆
2.   堆优化
     -   将所有的可能都入堆无疑会增加耗时，所以优化目的是降低数据量
     -   先从nums1中前k个数与nums2中的第一个数配对并一一入堆，出堆后再将其与nums2的下一个数配对并重新入堆

3.   



##### #376 摆动序列

1.   动态规划

     -   此题是#300的升级版，因为摆动序列涉及到两个状态：结尾上升、结尾下降，因此需要使用两个数组以维护两个状态，并且按顺序遍历数组，假设当前最佳结果包括了当前遍历值i
     -   遍历i之前的所有值以确保不会漏，若前面的值比i大，则使用其下降状态的值，反之使用其上升状态的值。遍历过程中维护最大值
     -   时间复杂度为O(n^2^)，空间复杂度为O(n)

2.   动态规划 优化

     -   因为存在两个状态，所以需要考虑之前的所有值都通过了这两个状态展现出来了。所以将状态数组定义为当前位置的最大值，得到状态转移方程。对于下降状态，状态转移方程同理

     $$
     up[i]=\left\{
      	\begin{aligned}
      	up[i-1],比前一位小 \\
      	max(up[i-1], down[i-1]+1), 比前一位大
      	\end{aligned}
      \right.
     $$

     -   因为仅需要前一个状态来进行转移，因此没有必要维护数组。此时时间复杂度为O(n)，空间复杂度为O(1)
     -   为什么这一题可以仅依靠前一个状态来转移，而不像#300一样需要逐个遍历呢？

3.   贪心

     -   为了让序列尽可能长，只需要将序列中的峰和谷的数量记录下来即可



##### #380 插入、删除和随机访问都是O(1)

1.   Set
     -   使用HashSet，最后获取随机值时先将HashSet导出为数组
     -   随机访问没办法做到O(1)
2.   Map+List
     -   随机访问显然需要一个list，所以要map与list搭配使用


##### #402 移掉K位数字
1. 暴力贪心【超时】
	- 首先找到规律性的结论
		- 想要数字最小，移除掉第一个大于后面数字的数字
		- 对于递增的数字区间，移除最后一个数字（或者把数字区间外的数字都看作极小值）
		- 一定是先移除靠前的数字才能保证数字最小
	- 循环k次使得移除k个数字，然后再进行前导零的检查以及是否空字符串的检查
	- 因为时间复杂度是O($k^2$)，导致超时
2. 栈
	- 思路一因为循环k次导致超时，所以思考一次遍历能够解决问题的方法。对于频繁的数字加入和移除，显然栈是最佳选择
	- 每次将数字加入栈时，先判断是否还需要移除数字，然后再判断要加入的数字是否比末尾的数字要大，不断移除直到找到适合的位置
- 未通过
	- 没有想到数字区间存在递增的情况应该怎么处理


##### #409 最长回文串

-   思路
    1.  最为回文串，字符应该成对出现，而正中间的字符可以单独出现。于是只需要遍历见过的字符并统计即可



##### #413 等差数列划分

-   思路
    1.  动态规划。假设每个数的结尾都在这个数列之中，于是只需要不断统计个数即可
    2.  贪心。不断遍历以观察其步长值，直到步长值发生改变或者到达尾端的时候才计算个数



##### #415 字符串相加

> 字符串

- 思路：直接逐位相加。注意不要忘了进位
- 注意
  - 字符串的第0位在左边。可以使用StringBuffer的`.reverse()`方法



##### #430 展平多级双向链表

-   未通过
    -   这是个双向链表，但是当原链表的下一个节点为null时，没办法填充其prev
    -   修改代码后没有测试
    -   方法名称没有概括其用意
-   思考
    -   尽管以0ms通过了，但是会担忧递归用得太多了
    -   对于一条链表，事实上可以直接使用循环处理就完成了。遇到新的链表后才使用递归



##### #435 无重叠区间:star: 

1.  动态规划
    -   首先是为整个数组排序。因为没有办法很好地遍历整个区间，为了能够用得上动态规划，这里令f~i~表示【以区间i结尾的最后一个区间，可以选出的区间数量的最大值】，从而得到转移方程$f_i=max_{符合条件的前区间}{f_i}+1$。遍历找到最大值即可
    -   注意，由于动态规划的耗时为O(n^2^)，所以在这题里需要谨慎处理细节。对每个位置的dp数组都使用一次Math.max()比大小会超时，但是可以预见的是上一个符合要求的区间的值才是最大的，所以不需要遍历比大小
2.  贪心
    -   假设当前位置是某一种最优选择方法的首个区间，那么其左侧没有其他区间，右侧则有若干个不重叠的区间。这时，只要其右侧足够小，就是最佳的首区间。不断把当前维护的区间当作首个区间，直到遇到下一个区间


-   提示
    -   没有想到用动态规划：涉及求最优解都应该想到动态规划
    -   二进宫：卡在了动态规划的状态转移上
    -   这道题动态规划最迷惑性的地方是使用了和#300相似的，对付LIS的动态规划算法。这是动态规划的变形模板，间接地省略了选与不选两种状态，以树的最大深度形式形成动态规划数组，应该熟记
    -   使用Math.max()的速度远比不上+



##### #437 向下的路径节点之和

1.   后序遍历以及列表维护
     -   在遍历的过程中维护数字列表，当后序遍历下的每个节点都对列表进行一次检查是否有符合的路径、有多少条
2.   使用前缀和以及哈希表优化
     -   因为每次都需要对列表检查一次，所以耗时较高，所以使用前缀和进行优化

-   未通过
    -   后序遍历写错了
    -   漏了题目中节点的值有负数，所以同一个起点可能会有多个终点
-   思考
    -   前缀和是一种思路，前缀和+哈希表是一种方式



##### #445 链表中的两数相加

1.   反转链表再处理
     -   为了让链表能够从低位往高位运算，只能够先翻转链表
2.   栈
     -   栈不仅解决了顺序相反的问题，也解决了对齐的问题

-   思考
    -   涉及反转，可以做链表反转，也可以用栈或者递归进行反转
    -   前者需要通过更改结构来进行反转，但是空间复杂度为O(1)
    -   后者无需更改结构，所以空间复杂度为O(n)



##### #450 删除二叉搜索树中的节点

1.   中序遍历、二叉搜索树特性

-   思路
    -   二叉搜索树BST的三个特性
        -   二叉搜索树的中序遍历是递增序列
        -   中序遍历的下一个节点（后继节点），在BST中先取当前右节点，然后一直取该节点的左节点，直到左节点为空
        -   前驱节点则相反
    -   java特性
        -   当引用被传递给方法后，形参指向null不能够让实参指向null



##### #452 用最少数量的箭引爆气球

-   未通过
    -   max的初始值设置不当，当没比较就返回时出错
    -   数组排序时，默认使用减法表示大小关系。但是这题遇到的极端情况是Integer.MAX_VAL减去Integer.MIN_VAL，所以返回的大小关系是错的
-   思考
    -   这道题没做出来的原因是卡在思考上了，不知道什么情形下是最少数量的箭

##### #456 132模式
- 未通过
	- “2”的选择有些草率，想都没想就直接用了最小值
	- 队列弹出的元素判断条件写反了
	- 弹出条件少了元素相等的情况
1. 枚举“3”
	- 先维护“1”，从左往右一直选择最小值即可。最小值显然会不断减小或不变
	- 再维护“2”，从右往左遍历找到大于“1”的最小值。从右往左看，这个值不断增大，所以需要使用PriorityQueue来记录并筛选合理的值
	- 最后枚举“3”，这一步可以和维护“2”一起进行，只需要找到大于“2”的值即可
2. 枚举“1”
	- 如果存在"3>2"，那么只需要再说明"1<2"即能够找到该模式。因为“1”在第一位，所以只需要一次从后往前遍历，并不断维护最大的“2”即可
	- 使用栈维护所有可能的“2”。在从右往左的维护过程中，先判断当前元素是否能够小于最大的“2”，作为“1”；然后再判断当前元素能否作为“3”，如果能，则重新整理栈，通过弹出元素找到最大的“2”
3. 枚举“2”
	- 因为枚举“2”只能通过查找是否存在合适的区间，所以需要通过栈维护区间并通过二分查找找到是否存在合理的“2”
- 思考
	- “3”的位置在中间且是最大值，所以枚举“3”最容易想到；“1”最小，所以做起来不太难；相比起来，“2”有一些棘手



##### #459 重复的子字符串

1.   暴力枚举
     -   先遍历得到子字符串符合要求的长度，然后不断截取该长度下的子字符串，并逐个使用equals来比较字符串
2.   字符串匹配
     -   令符合要求的字符串为s，字符串子串为s‘，如果移除字符串s的s’，然后保持顺序添加到末尾，那么得到的字符仍是s
     -   如果将两个s连在一起，并移除第一个和最后一个字符，那么得到的字符串一定包含s，即s是它的一个子串
     -   因此只需要一句话就可以判断是否符合要求
3.   KMP算法
     -   基于思路二，将其搜索替换为KMP

-   思路
    -   题解对于子字符串的利用十分出色



##### #486 预测赢家

1.   递归
     -   要知道分数和是固定的，所以一个人的分数变多，另一个人的分数必然减少
2.   动态规划
     -   定义二维数组dp(i,j)表示在下标范围[i,j]中，当前玩家与另一个玩家的分数之差最大值
     -   从只有一个数字开始遍历，最终结果为dp(0, nums.length-1)

-   思考
    -   对于动态规划，永远只关心当前最优方案，后续的结果就交由枚举完成即可
    -   对于本题的动态规划，并无意于知道当前是否先手玩家，这符合题意“两位玩家游戏时都表现最佳”。只需要确定最终结果一定是先手玩家即可



##### #489 扫地机器人

1.   dfs
     -   遍历4个方向是否能够移动，若不能，则返回

-   思考
    -   这一题有了思路，但是却写不出。想到了dfs，但是在返回上一步状态中没有思考到这是递归，所以只需要让机器人走一步就好了



##### #515 二叉树每层的最大值

-   未通过
    -   把最大值初始化为0，但是实际上数值范围有负数



##### #516 最长回文子序列

1.   动态规划
     -   将每个位置的最长回文子串记录在数组中，由于每个位置包括了起点和终点，于是需要使用到二维数组。同#5



##### #518 零钱兑换Ⅱ :star: 

1.  动态规划-组合
    -   为了使得不会重复计算不同的序列，所以使硬币面额作为外层循环，价格作为内层循环。



##### #525 连续数组

1.   暴力+前缀和+哈希表

     -   遍历，并将当前位置i的前缀0数量和前缀1数量记录
     -   记录前，不断往哈希表查询当前位置下可能的最长长度，从前缀0数量和前缀1数量两者的最小值开始向下遍历
     -   超时

2.   前缀和+哈希表

     -   将表中的0值改为-1，这样，只有前缀和之差为0时，当前位置到起始位置的0和1的数量相等。这步不是必须的，而是帮助思考的一步，这么做后找到了前缀和模板
     -   使用哈希表维护前缀和，并且值为下标，不重复添加

3.   贪心+数组优化：：待实现

     -   事实上，哈希表不会重复添加新的前缀和，这给了贪心一个机会

         

-   思考
    -   前缀和与前缀和之差
    -   方法二的使用犹如一个模板




##### #542 01矩阵

> bfs

- 思路
  1. 原来的思路是遍历每一个元素，若当前位置为1，则搜索最近的0。苦于无法利用相邻元素提高整体效率，所以超时了。
  1. 先找到所有的0并添加到队列中，然后开始遍历1有多远



##### #556 下一个更大元素Ⅲ

-   思考
    -   将int转为char数组再处理（先转字符串）
    -   最后使用try-catch来paresInt以确保其没有溢出



##### #557 反转字符串中的单词

> 双指针

- 思路
  1. 先将字符串转为char[]，右指针不断右移寻找空格或字符串结束处，左指针则指向空格右边的字符，这样界定了一个单词，使用双指针靠拢进行反转。最后将char[]导入到StringBuffer中再转String
  2. Java不能直接操作String类型，所以一定需要开辟新空间，所以可以每找到一个单词就把他的倒序放入字符串中



##### #560 和为k的数组

1.  暴力
1.  前缀和+哈希表
    -   前缀和可以一边遍历一边维护，这样哈希表中的值总是在当前位置之前的

-   思考
    -   一开始把前缀和与遍历过程割裂了，所以觉得哈希表的使用不可行
    -   没有想过哈希表可以动态维护



##### #572 另一棵树的子树

1. 暴力递归
    -   遍历一棵树，并对每一个节点进行一次检查，确认是否该节点为subRoot节点
    -   时间复杂度为O(s*t)，空间复杂度为O(max{ds,dt})（树的深度）
2. 映射成串
    -   一棵子数上的点在DFS中是连续的。于是可以考虑先将两颗树转为字符序列，然后再匹配
    -   为了防止空节点对字符序列的干扰，这里引入了两个空值lNull和rNull，当一个节点左孩子或右孩子为空时，就插入这两个空值
    -   字符串的匹配可以使用暴力，也可以使用KMP或者Rabin-Karp算法，后者可以将时间复杂度优化至O(s+t)。空间复杂度为O(s+t)
3. 映射成哈希值

-   思考
    -   （当你有足够能力的时候）处理一棵树，将其映射后能够提高处理速度

##### #593 有效的正方形
1. 对角线
	- 两条对角线，中点相同是平行四边形，加上长度相等的条件是矩形，再加上对角线相互垂直就是正方形
	- 题目给了四个顶点，但不知道哪两个点是一条边的，所以一一枚举即可
- 思考
	- 想到了另一个不错的方法，但是卡在了怎么知道哪一条线是边导致超时了。这个失误有点好笑，毕竟才4个点，一一枚举也不会太麻烦
	- 作出了多余的担忧：求边长显然用到了勾股定理（没有想过这一点），不会导致精度溢出；求中点显然只是长度宽度各除以2（也没有想过这一点），同样不会导致精度溢出
	- 没有敢于更深一步的思考

## 6+

##### #617 合并二叉树

> 树

- 思路
  1. 想着是用dfs，但是递归写得2不好，着重点在当前结点的左右结点，因为没有处理好非空的关系，所以失败了
  2. 答案的dfs着重点在当前结点上，每次进入函数先判断该节点是否为空，使得处理方便

##### #623 在二叉树中增加一行
- 未通过：逻辑错误，增加行为空时没有增加节点

##### #634 寻找数组的错位排列

1.   动态规划

     -   总是假设第一个数被抽取，并和放在了位置x上。如果位置x的数放在了位置1上，那么剩下的n-2个数需要打乱；如果位置x的数没有放在位置1上，那么因为除了x之外的数字都不能放在自己的位置上，而x不能放在位置1上，需要打乱n-1个数

     -   设f(n)表示n个数进行错位排列的方案，因为位置1有(n-1)个位置可以选择，因此有

         `f(n) = (n-1)*(f(n-1)+f(n-2))` 

-   思考
    -   一开始想的是dfs，但是看到数据量达到了10^6^就觉得一定会超时
    -   因为只需要求出错位排列数量，所以dfs一定是不必须的
    -   这题的动态规划转移方程太妙了，充分地用到了之前的状态



##### #651 4键键盘

1.   多状态的动态规划（未尝试）
2.   动态规划优化1
     -   可以看作是两个操作：加法和乘法
     -   遍历每个位置，并比较加法和乘法哪一个会带来更大 的收益
     -   对于乘法，需要从0开始遍历找到最佳的位置进行乘法运算

-   思考
    -   这题尽管有4个按键，但是对结果产生影响的只有2个状态：输入和全选-复制-粘贴一系列操作。而全选-复制-粘贴这一操作可以看作是操作次数少了2次的乘法运算，这样一来问题得到了简化

##### #669 修剪得二叉搜索树
- 未通过
	- 考虑的条件不周全
1. 递归
	- 判断当前节点是否符合，如果不符合，则返回符合的子节点
2. 迭代
	- 因为二叉搜索树是有序的，因此可以通过一次遍历就完成操作


##### #670 最大交换
- 未通过
	- 策略有误
1. 暴力
2. 贪心
	- 最大值与左侧较小值不断交换

##### #672 灯泡开关Ⅱ
1. 找规律
- 思考
	- 能够得出结论灯泡每6个一周期，但是没有找到按下按钮的规律，所以没能够做出来
	- 需要明白按钮按下两次后，结果是不会产生变化的。所以知道了当按下次数大于4时，所有可能的情况一定不会大于$2^4$。


##### #673 最长递增子序列的个数

1.   动态规划
     -   与#300是同样的思路，但由于此题需要获取的是最长子序列的个数，所以需要使用额外的数组记录其每个位置最长子序列的数量

-   思考
    -   对于自身而言肯定更偏向于使用性能更优的贪心算法，但是却不能够证明为什么这样贪心是正确的，最终变成了面向测试用例编程
    -   因为贪心没办法尝试出来，随后更换了动态规划，但既没写状态转移方程，又总是想着省去数组的使用，最终白白折腾了很久，写出来逻辑混乱的代码



##### #676 实现一个魔法字典

1.   前缀树
     -   将每个字母作为树的节点
     -   找不同时，需要遍历26次
2.   哈希暴力
     -   将单词长度作为键，所有同样长度单词的列表作为值
     -   直接比较单词之间相差的字母是否超过1个
     -   使用双指针从两边一起搜索可以加快效率


##### #678 有效的括号字符串
- 未通过
	- 没办法解释“()()”怎么通过动态规划解决
1. 动态规划+暴力
	- 为“()()”使用暴力，分割出不同括号范围区域


##### #680 最多删除一个字符得到回文

1.   递归/贪心
     -   从两端遍历比较是否相同，因为遇到字符不相同时意味着遇到了多的字符，可能多的字符可能是前者，也可能是后者。因此需要两次比较
     -   所以选择使用递归
     -   后来重新删除多的字符的机会只有1次，所以在递归函数中加入了一个boolean flag
2.   贪心优化
     -   正因为删除多的字符的机会只有1次，所以递归也没必要使用了。因为如果删除多的字符后，必须保证剩下的字符串完全回文

##### #687 最长同值路径
- 未通过
	- 对子路径的处理有误，导致可能会返回有分岔的路径


##### #688 骑士在棋盘上的概率

1.   dfs记忆化
     -   返回概率并相乘

-   思考
    -   一开始担心double类型会出现精度爆炸的问题，然后引入了除法以为能够解决问题。后来才想起乘法不会导致精度爆炸，但除法会
    -   dfs的每个节点也相对于动态规划的一个状态了。但是自己在想状态时没想通怎么转移。概率等于子概率乘以子概率



##### #694 不同岛屿的数量

1.   并查集（未尝试）
2.   dfs
     -   从海岛的左上角开始遍历，并将遍历路径记录，作为标识海岛形状的字符串
     -   将这些字符串加入set中，最后返回set的大小即可

-   思考
    -   题目的难点在于如何标识岛屿的形状，但是我却没有找到这个重点
    -   使用dfs才可以确保一定是从海岛的左上角开始遍历，这样也省去了找到海岛后再确认其上下左右边界
    -   对于相同形状的海岛，dfs的路径是唯一的



##### #695 岛屿的最大面积

> 图

- 思路
  1. 不断按顺序遍历二维数组，若发现一个未遍历过的岛则开始测量其面积，并将遍历过的大陆标为2，使用的是广度优先。最终通过不断比较得到最大岛的面积。注意不要看错题，虽然岛的数量和最大岛面积数值一样
- 感想
  - 深度优先和广度优先算法的区别就在于广度优先核心是队列，而深度优先核心是栈（递归可以用栈（Deque）代替）


##### #698 划分为K个相等的子集
1. 暴力
	- 先对数组进行排序，然后从最大的数开始遍历，不断尝试往子集中插入数字，并使用栈记录插入位置
	- 插入数字的过程中，找到能够插入的子集；如果能够插入，则继续遍历下一个数字；如果不能够找到插入位置，则回到上一个数字，找到下一个合适的插入位置
	- 最后还要设置，如果第一个数字插入第一个子集无法找到正确结果时，说明无法找到正确结果，需要返回false，防止继续在第二个子集开始多次遍历
2. 记忆化搜索：没看懂
- 思考
	- 对于暴力算法
		- 首先是递归过程（虽然我使用了循环）返回上一个数字时，没有记得将子集的和恢复，而且检查代码后也没有找到结果，直到最后打开VSC检查了才发现问题
		- 其次是没有想到超时问题，导致了一次出错



## 7+

##### #703 数据流的第k大数值

-   未通过
    -   一开始的做法使用了两个堆来维护数据。虽然题目说确保在遍历时有第k大元素，但没有说在初始化时就保证有第k大元素



##### #704 二分查找

> 双指针-二分查找

- 思路

  1. 因为数组元素有序，所以使用二分查找

- 二分查找算法:star:

  ```java
  public int search(int[] nums, int target){
  	int mid, l = 0, r = nums.length-1;
  	while(l<=r){
  		mid = (r+l)/2;
      // mid = l + (r-l)/2
      // 等效写法，但是能够避免溢出
      if(target<nums[mid]) r = mid - 1;
      else if(target>nums[mid]) l = mid + 1;
      else return mid;
  	}
  	return -1;
  }
  ```

  - 注意观察如何避免数组只有一个元素时进入不了循环
  - 注意左指针和右指针和mid指针的区别，这应该和答案区间有关，也是为了让指针最后能够相等，以及退出循环



##### #706 设计哈希映射

1.   哈希值的使用
     -   base为一个常数，这里选择了质数769
     -   哈希值通过整数除以base得到，并使用base个链表数组用于储存数据



##### #708 排序的循环链表

-   未考虑
    -   只有一个node的时候，pre指针和curr指针都指向同一个
    -   当插入值比当前链表中的所有值更大或更小时
    -   漏了相等的情况



##### #710 黑名单中的随机数

1.   二分+映射
     -   为了得到的随机数概率平均，所以应该将黑名单的数和白名单的数分离，然后在白名单中找到该值
     -   因为白名单的数字较多，所以选择处理黑名单的数字，于是希望将黑名单数组映射成可以找到白名单数字的方法。令所有数字数量为n，黑名单数字数量为m，在\[0,n-m)的范围内选取数字，如果这个数字大于黑名单数组的某个数，则将其还原。
     -   所以令黑名单数组每个数字减去自身index，然后再还原时，通过二分查找找到大于等于黑名单数组的最大值并加上index使得成功复原
2.   映射优化
     -   思路同上，希望在\[0,n-m)的范围内选取数字能够映射出白名单数。但是希望能够把二分查找的时间也节省了，所以用到了哈希表
     -   在\[0,n-m)的范围内的数字中，如果这个数字是黑名单数，那么在\[n-m,n)的范围内找到一个白名单数，并建立映射。当选择到一个黑名单数时，就返回其映射到的白名单数



##### #713 乘积小于k的子数组

1.   暴力
     -   因为在连续数组中，一旦值超过target，则之后的乘积都会超过target。使用该思路进行剪枝
2.   二分查找
     -   因为担心运算过程中，乘积会溢出，所以使用了对数运算来代替
     -   使用思路1的剪枝思路，并使用二分查找找到这个临界值
3.   滑动窗口
     -   因为数组中只有正整数，那么乘积总是会因为乘法因子的个数而增大。意思是只要维护一定数量的乘法样子，乘积就会小于k。因此使用双指针进行遍历
     -   以右指针作为子数组右端点，通过调整左指针使得乘积刚好达到不越界的最大乘积。那么，在此区间内的子数组都符合题目要求，数量为right-left+1
     -   这样使得时间复杂度为O(n)


-   思考
    -   思考答案的来源是否可追溯



##### #714 买卖股票的最佳时机含手续费

>   动态规划、贪心

-   思路
    1.  见309
    2.  使用贪心算法：对于股票，只要每次出现扣除手续费后仍能够盈利的情况就是将其统计，最后得到总盈利



##### #721 账户合并

-   超时
-   思考
    -   有时候一味地想着走近路，最后既不知道怎么正常走路，也变得害怕正常走路了
    -   有时候自己会将很多个步骤抽象为一个步骤，导致最后吓到自己，以为写不出来了



##### #724 左右两边子数组的和相等

1.   后缀和
     -   先得到后缀和，然后通过从前往后遍历的方式得到前缀和。两者比较找到答案
     -   时间复杂度O(n)，空间复杂度O(1)
2.   后缀和优化
     -   后缀和的值显然等于总和减去前缀和，空间复杂度能优化为O(1)


##### #726 原子的数量
- 超时


##### #727 最小窗口子序列

1.   动态规划
     -   因为需要找到长度相关信息，而序列的终点是可以知道的，所以状态的内容应该是最大的起点位置

-   思考
    -   动态规划的状态内容卡住了，转移也卡住了
    -   状态内容卡住了是因为没有思考题目返回值需要什么
    -   转移卡住则是因为没有找到遍历顺序



##### #729 我的日程安排表Ⅰ

1.   暴力
2.   使用TreeMap优化
     -   使用`floorKey()`找到前一个键
     -   使用`ceilingKey()`找到后一个键



##### #733 图像渲染

> 图

- 思路

  1. 广度优先：不断把未更换前颜色的区域加入到队列中，通过换成最新颜色、出队表示遍历过的区域，当出现更换前颜色与更换后颜色相同的情况时应该直接返回原数组，否则会出现死循环
  2. 深度优先：

- 提示

  1. 数组是可以加到队列中的

     ```java
     Queue<int[]> queue = new LinkedList<int[]>();
     queue.offer(new int[]{sr,sc});
     ```

  2. 不用直接为上下左右四个方向各写1次判断，可以添加到数组，然后通过循环操作

     ```java
     int[] dx = {1, 0, 0, -1};
     int[] dy = {0, 1, -1, 0};
     // 上下左右
     ```



##### #735 小行星碰撞

-   未通过
    -   代码中有多个条件语句，但自己少判断了几种条件。比如栈顶是负数
-   思考
    -   栈很适合用于只需遍历一次，然后等待被处决的数据



##### #741 摘樱桃

1.   一次两条路的动态规划
     -   使用dp数组，定义dp\[x1]\[x2]是两个人从(x1,y1)(x2,y2)开始朝着终点所能够摘到的最多樱桃的数量
     -   因为两人的已行驶路径长度相同，所以y1和y2可以通过计算得到
-   思考
    -   一开始在想走两次路是否等价于两次都是走最佳方案路径的结果，因为没想到反例，所以就照着做了。当然，最终测试案例里给了反例说明这种想法是错的

        ```
        1 1 0 0
        0 1 0 1
        1 1 0 0
        0 1 1 1
        ```


##### #761 特殊的二进制序列
1. 递归
	- 因为一个特殊的二进制序列，被切割后的子序列同样是特殊的，所有考虑使用递归的方法
	- 递归需要减少处理的数据量，考虑到特殊的二进制序列首必为1，尾必为0，所以可以截去首尾再进行递归
	- 最终将同一层级处理后的所有序列排序再集合
- 思考
	- 没有留意“特殊的序列中切割出特殊的子序列”这一观点，也没想过这种观点可以引出递归的做法


##### #763 划分字母区间

>   贪心

-   思路
    1.  首先要了解每个字母的最后一次出现的位置，然后使用贪心划分尽可能多的片段。由于对于每个访问过的字母c，得到了最后一次出现的下标end_c时，则当前片段结束的下标一定不会小于end_c，因此有`end = max(end, end_c)`

##### #765 情侣牵手
1. 直接替换
	- 先使用哈希表记录每一个元素的位置，然后再遍历一遍数组，为每一个不匹配的情侣替换偶数位的值，并统计替换次数
2. 并查集
	- 在数组\[0,3,2,1]中，需要替换一次就能让错位的两对情侣正确牵手
	- 在数组\[0,3,2,4,1,5]中，需要替换两次
	- 在数组\[0,3,2,1,4,7,6,5]中，需要替换两次
	- 在数组\[0,4,2,6,1,3,5,7]中，则需要替换三次
	- 因此找到规律，坐错了位置，且逻辑上连在一起的情侣块中，需要替换次数=情侣数-1
	- 逻辑相连是指像例子三中，数组可以被分为\[0,3,2,1]和\[4,7,6,5]，这两个数组内部就可以完成交换
- 思考
	- 很高兴自己能够找到方法二的思路，虽然看完方法一觉得这样做也是正确的有点不可思议。自己做到了从拼答案找到了规律，虽然这个过程出现了小插曲，一开始没能够看到其中的“逻辑相连”的概念，毕竟这起码需要4对情侣才让这个概念变得明显
	- 分块的思路下次应该被留意到

##### #768 最多能完成排序的块 Ⅱ
1. 贪心【超时】
	- 对于第一个处理的块，必定存在块中最大的元素小于之后所有元素的最小值
	- 所以使用PriorityQueue维护块中最大的元素，使用链表维护未被处理的元素并对链表进行排序。只要符合条件，既可以分块
	- 由于处理元素的同时链表之中必须删除对应的元素，但是这一部分只能通过遍历完成，导致时间复杂度较高，最后超时
2. 贪心优化
	- 如果对应块可以被分块，那么该块对应的坐标与排序后数组对应坐标内的所有元素必然一一对应存在
	- 于是可以通过统计词频的方式确认这种关系：在默认数组中遇到则词频+1，在排序数组中遇到则词频-1，如果词频为0则移除。当哈希表为空时，表示可以分块


##### #778 水位上升的泳池中游泳

1.   最小生成树/Prim/迪杰斯特拉
     -   把二维数组中的每个数字看作是到达该位置的花销，那么一个最小生成树就被构造出来了。使用优先队列维护所有能够抵达其他位置并按照花销来排序
2.   并查集
     -   每经过一个时刻，就把此时和雨水相等的单元格找到，并将其周围连接
     -   使用并查集维护连接，直到起点和终点能够相连
3.   二分与bfs/dfs
     -   不断假定一个结果t，并使用bfs/dfs遍历来确定当前时刻下是否能够抵达终点

-   思考
    -   这道题超时了，没做出来
    -   想过暴力bfs，但是想着可能会超时，没有想到要用二分查找
    -   没有想到并查集，这题涉及了两个点之间能否联通的子问题，应该要先想到并查集

##### #782 变为棋盘
- 做不出

##### #787 k站中转内最便宜的航班

-   未通过
    -   没有处理map中无此key的情况

1.   dfs
     -   对于每个节点，都遍历一遍能够抵达的城市，并返回最小价格
     -   需要注意的是，直接使用dfs会超时，需要做记忆化搜索，将dfs的记录保存在数组中
2.   动态规划
     -   与dfs不同，动态规划依赖之前的状态

-   思考
    -   因为一开始以为dfs就是迪杰斯特拉算法，所以还在每个节点获取所有路径时排序，而且也没有做记忆化搜索，所以直接超时
    -   对于dfs的每个节点来说，之后的状况可能重复的概率会很大，遍历的同一状况节点的次数也可能很多，所以使用记忆化很重要
    -   一开始遇到超时很无语，不知道自己能够做些什么，想到网易的笔试也遇到了这种情况。不过在这题里遇到了解决方法，应该挺幸运的
    -   遇到最短路径应该要想到动态规划的

##### #793 阶乘函数后k个零
- 做不成


## 8+

##### #814 二叉树剪枝

1.   先检查后处理（先序）
     -   对树进行先序遍历，并在遍历过程中检查左右子树是否全为0
     -   因为涉及树节点的删除，所以检查的对象是树的左右节点，而不是自身
2.   边检查边处理（后序）
     -   先检查后处理意味着一棵树可能会遍历多次，因此使用边检查边处理可以提升效率
     -   使用非递归的方式（栈）很难将某个node直接置空，所以使用递归会很好解决

-   未通过
    -   遍历过程中写错了，检查了root而不是curr的左右节点是否为空
    -   漏了整棵树都是0节点的情况，这也算是一棵子树


##### #828 统计子串中的唯一字符
1. 分别计算每个字符的贡献
- 思考
	- 因为字符串最长可达10^5的长度就在想，这题就算是仅仅得到每个子字符串都要超时了，不知道能怎么办。看了题解后才想起题目确实没有要求得到每个子字符串。所以划分子串再统计的方法是不可行的
	- 既然划分子串不可行，那么就尝试以字符为单位进行统计
	- 对每个唯一的字符，通过乘法原理把所有可能的起始子字符串位置和结束位置进行相乘


##### #834 树中距离之和

1.   树形动态规划

     -   对于一棵树的根节点，很容易想到

     -   一个树形动态规划：定义 dp[u]表示以u为根的子树，它的所有子节点到它的距离之和，同时定义 sz[u]表示以u为根的子树的节点数量。对于根节点，距离和为

         dp(u) = $\sum_{v\in son(u)}dp(v)+sz(v)$，son(u)为子节点的集合

     -   对于每棵树，既可以通过暴力完成，也可以通过换根来降低时间复杂度，每次通过转换父节点和子节点，会发现除这两节点外，其他节点的状态值dp不会发生更改，且当根节点u变为根节点v时，有

         dp(u) = dp(u) - (dp(v)+sz(v))

         dp(v) = dp(v) - (dp(u)+sz(u))

     -   通过该关系式，可以做到在O(1)内完成换根操作，得到所有答案

-   思考
    -   之前苦于只有根节点的距离之和容易求而其子节点的距离和不容易求，也苦于不知道应该选哪一个节点作为根节点较好，所以没有做出来
    -   看到题解明白了这些方向确实不太好做，所以先从根节点下手维护dp值，然后通过换根找到规律。可以看到，更换根节点的做法比死守树的模型不变的思路更容易做



##### #844 比较含退格的字符串

1.   重构字符串
     -   先得到两者被处理后的字符串，然后再比较字符串是否相等。可以使用栈或者双指针得到
     -   时间复杂度为O(N+M)，空间复杂度为O(N+M)
2.   双指针
     -   一个字符是否会被删除，取决于该字符后面的退格符。因此，从后往前一次遍历，可以方便地知道该字符是否会被删除
     -   这样提供了让两个字符串同时遍历的可能。两个字符串同时不断地逆序遍历字符串得到会被保留的字符，若对应的字符不相等，则说明最终字符串也不相等
     -   时间复杂度为O(N+M)，空间复杂度为O(1)

-   提示
    -   若出现两个列表之间的比较，则应该思考是否能够不经过预处理就开始同时比较


##### #857 雇佣K名工人的最低成本
1. 暴力【超时】
	- 显然题目需要的工人应该是质量不高而且比例不大的人群，在这么多人中没有很好的办法评价每一个工人如何，只好先求出每种可能的开销
	- 容易找到公式：总开销 = 总质量 * 最大比例
	- 所以接下来要做的事是先对比例排序，然后再枚举不同的最大比例下统计最小的总质量，从而找到最小的开销
	- 时间复杂度是O(n^2)，所以超时了
2. 贪心/滑动窗口
	- 贪心的依据仍然是思路1的公式，但是选取的角度是从质量下手
	- 同样先对比例排序，这样就能够在滑动窗口时，最大比例总是出现在末位
	- 在这题中，滑动窗口并不是通过双指针维护，而是PriorityQueue，这样才能保证总质量是当前最小
	- 使用滑动窗口不断比较总开销，找到最大值
- 思考
	- 从n中选择k时，应该要将做法往滑动窗口上思考，从而降低时间复杂度
	- 在使用思路1时，虽然知道怎么求出总开销，但是没有想过推出公式，所以也没能想到如何更换角度从而解决问题
	- 在使用思路1时，想到要用二分法降低时间复杂度，不过最终没法说明总开销随着最大比例的增加而改变的特性而无从下手



##### #871  最低加油次数

1.   动态规划
     -   因为每到达一个加油站都可以加一次油，所以n个加油站一共可以加n次油，使用长度位n的数组表示加n次油最多可抵达的位置，最后再找到能够抵达终点的最小加油次数
2.   贪心
     -   在跳跃问题翻版的基础上，使用PriorityQueue记录所有能够抵达的加油站
     -   当出现半路中途已经没办法走得更远了的情况时，从优先队列中取出最大值并续上，直到遍历了所有的油站，从而使得中途加油可以被表达出来

-   思考
    -   一开始想到的是这道题是跳跃问题的翻版，所以使用贪心记录每个位置加油后能够抵达的最远位置；后来提交时出错了才想到两道题是不一样的：可能需要每经过一个加油站都需要加油才能够抵达终点，而跳跃问题的贪心算法不能够处理这种状况
    -   后来想到了青蛙跳石子过河的问题，想通过二分查找的方式找到最少需要加多少次油，但是因为没办法指定在仅加k次油的情况下怎么到达终点，所以没办法做
    -   基于上一个思路，才想到动态规划的方法，但是耗时将近1小时
    -   贪心思路解决了我的第一个思考无法做出来的问题。因为没有想过贪心能够可以和数据结构一起出现，也不知道有什么东西值得记录，所以想不到



##### #887 鸡蛋掉落

1.   动态规划

     -   每一次扔鸡蛋，都是一次角逐：是如果蛋碎了要扔的次数多，还是如果蛋没碎要扔的次数多。此次扔鸡蛋后，操作次数是两者的最大值

     -   令鸡蛋数量为k，楼层总数量为n，扔鸡蛋的楼层为x，则有转移方程

         max{dp(k-1, x-1), dp(k, n-x)}

     -   x的取值是1到n，需要找到本次状态转移中，令操作次数最小的x值，因此补充状态转移方程为

         dp(k,n) = 1+min~1<=x<=n~{max{dp(k-1, x-1), dp(k, n-x)}} 

     -   因为操作次数必定会随着楼层的增加而增加，所以随着x增大，`dp(k-1, x-1)`会单调递增，`dp(k, n-x)`会单调递减，因此最小值会出现在1到n的中间，所以考虑使用二分查找找到该值

     -   因为状态转移方程涉及参数n，所以没办法直接从1往上遍历，必须使用“如果该值为空，则先获取”的思路，配合哈希表来完成该题

-   思考
    -   因为之前的动态规划都是可以从1开始向上遍历的，所以当写状态转移方程时，发现要使用参数n，以为自己写错了。因为有了参数n，所以只要n不同，动态规划的结果数组就会不同。紫萼不出方程，这是因为自己对题目产生思维定式导致的
    -   第二次做时在写状态转移方程时定义错了每个状态，导致卡住了。卡住时应该想想是否定义出现了歧义



##### #896 单调数列

1.   一次遍历
     -   一定要留意差值为0的情况以及位置，否则会拼命踩坑



##### #897 展平二叉搜索树

1.   重造
     -   不断获取中序遍历的节点的值，然后以新节点的方式呈现在递增树中
2.   仅改变指向
     -   通过改变指针指向实现不用重造节点就完成了递增树

-   思考
    -   遍历过的数据或节点就没用了，所以可以随心所欲，可以被利用，不必担心


##### #899 有序队列
1. 分类讨论
	- 当k=1时，没有办法改变队列顺序，只能够通过遍历找到哪一个字符串作为开头可以使得队列最小
	- 当k>1时，因为可以改变队列的顺序，能够使得某个元素作为队首，因此一定可以将s改为升序字符串。因此其结果不需要模拟，只需要排序即可
- 思考
	- 这道题没能做出来是因为没有看到题目的规律，包括看了题解之后还是一头雾水。重新去尝试拼出有序队列会发现有点像是九宫格拼图，需要一个位置作为预留位，一个位置组为可插入的位置。所以这题中k>1时一定能够随意得到想要的结果
	- 觉得力不从心是因为直接拼的时候自己都几乎要放弃了，只能得出结论是一定要亲手拼出题解才可以找到题目的规律


##### #910 最小差值Ⅱ

1.   贪心
     -   先排序数组，然后以两两比较的方式进行遍历

-   思考
    -   直接想获得最小差值的做法看起来比较难，因为没办法确认选择增还是减。一开始想到的方法是根据均值来处理，但是没有办法证明这是确定的
    -   所以需要更改大环境后再处理数据。显然，排序后再处理数据不会对结果造成影响，所以先进行了排序
    -   对于排序结果的第一个值，肯定选择其增加后的结果；对于排序结果的末值，也当然是选择其减后的结果。但这两个结果对中间的数的最大最小值并不通用，所以需要逐个遍历
    -   对于整个数组，值较小的部分总是应该选择增加，而值较大的部分总是应该选择减小。但哪里才是较小和较大的分割点呢？所以需要逐个遍历，找到使得结果最小得分割点
    -   这道题需要先处理大环境，再对小环境进行比较



##### #918 环形子数组的最大和 :star: 

>   贪心、动态规划

-   思路
    1.  为了解决环形子数组的遍历不方便的问题，我将两个原数组凑成了一个新数组。但是由于无法解决子数组超过最大长度的问题，因此无法完成
    2.  可以把原数组中元素分为在子数组内的元素和其他未被选择的元素。这样，两者总有一部分是相连未被分割的，当未被分割的部分为其他元素时，通过总和减去这部分元素和得到的结果就是子数组之和。子数组内的元素加起来是当前位置前的最大值，则剩下的元素是当前位置下的最小值，因此只需要一次遍历，并同时查找最大值和最小值，然后在返回结果的过程中比较哪个更大即可。要注意的是，假若最小数组占用了数组的所有元素时，不能直接返回（总和-最小），因为此时理论下的子数组没有元素，这不符合题意
    3.  子数组的组成有两种情况：一个区间，或者首尾两个区间。事实上分类讨论也不难，一个区间的情况很好做，而两个区间的情况则是先为头部区间遍历得到[0,i]之间的最大值，然后再根据左指针的位置提供这个最大值



##### #924 尽量减少恶意软件的传播

-   未通过
    -   变量值写错了
    -   理解错题意的“最小”
    -   缺少部分情况的“最小”的比较
    -   比较写漏了条件

1.   并查集——使用祖先作为标记
     -   先构造并查集，然后再使用哈希表统计祖先的节点数量，然后再使用另一张哈希表统计当前连通分量下的初始感染数量。最后遍历得到使得影响最小的目标节点，如果同一联通分量下只有一个初始感染节点，则能够造成影响。
2.   并查集——使用id作为标记（未尝试）
3.   dfs（未尝试）



##### #928 尽量减少恶意软件的传播

1.   暴力、并查集
     -   因为可能在移除某一节点以后，某一连通分量会裂开为两个联通分量，所以没办法直接相连后再统计
     -   所以这里对每一个初始感染节点都遍历了一遍，以统计当该节点不存在时的电脑感染数量
     -   因为数据量不大，所以没有超时
2.   并查集优化
     -   先将非初始感染的节点连接起来
     -   然后执行初始感染节点的连接，并统计能够感染节点的数量
     -   最终遍历得到最小值

-   思考
    -   不需要担心使用暴力的方式

##### #952 按公因数计算最大组件大小
1. 并查集+暴力【超时】
	- 每两个数提取一次公因数，如果大于1才使用并查集连接
	- 由于提取公因数是一个耗时的操作，所以超时了
2. 并查集+埃氏筛
	- 将每个数字都作为并查集的一个节点表示因数，然后对数组中的每个数字在因数中进行遍历，如果因数是这个数字的，则相连
	- 最后返回因数中连接数量最多的量
- 思考
	- 思路1和思路2的区别不仅是对数字的判断上从gcd函数转换为埃氏筛，更是把角度从数字转换为了因数。将因数作为并查集的节点是因为对于埃氏筛需要做的是找到拥有因数的数量，而这些因数也因为数字从而得到了相连


##### #977 有序数组的平方

> 双指针

- 思路
  1. 因为数组有序，所以用双指针。先找到正负交界处，然后双指针不断往外扩散，直到填满整个数组为止
  2. 同样是使用双指针，但是可以把指针指向数组两端，不需要判断正负，只需要不断比较指针处平方结果，并按照从大到小的顺序放入数组，直到指针相遇



##### #983 最低票价

1.   多状态的动态规划（未尝试）
     -   从前往后地遍历，并比较哪一种方式的开销最小
2.   记忆化搜索/动态规划
     -   令dp(i)为从i往后的开销，从后往前遍历三种票价得到开销的最小值

-   思考
    -   在这道题中，从后向前迭代显然比从前往后遍历要更方便。这是因为购买一张n日票后需要对比的是之后的票价，所以应该要从后往前遍历



##### #997 找到小镇的法官

1.   双哈希表
     -   set用于放入不可能是法官的人，而map用于放入有可能是法官的人选
     -   最后查看候选人是否只有1个且是否有n-1人都给法官投票了
2.   统计节点的入度和出度
     -   毕竟法官不会信任人，但被所有人信任，于是统计所有人信任数量和被信任数量，然后找到匹配的即可
     -   使用数组比哈希表速度更快


##### #998 最大二叉树2
1. 递归
	- 先通过中序遍历得到原来的数组，然后再通过数组的最大值获取节点插入的区间，最后通过不断缩小区间找到插入位置
2. 直接遍历树
	- 因为插入值是数组的最后一个节点，因此只需要不断往右遍历节点，知道找到一个比自身小的数即可

## 10+

##### #1014 最佳观光组合

>   动态规划

-   思路
    1.  暴力：时间复杂度为O(n^2^)，固超时
    2.  要解决超时问题只需要做到空间换时间即可，于是通过观察，发现对于景点而言，最佳景点假若不是因为重复或冲突，都是同一个，于是使用优先队列PriorityQueue排序得到下一个最佳景点。
    3.  `values[i] + values[j] + i - j`。这是题目的公式，可以拆为`values[i]+i`和`values[j]-j`。因为在遍历i或j时，另一个的最大值始终不变，于是可以遍历j，`max(values[i]+i)`的值则可以边遍历边维护。该做法与思路2大致相同，只不过其最大值的诞生思路2是在遍历者后方，要先使用优先队列获得，思路3则是一边遍历一边维护。其次，思路2的获取是通过观察现象得来的，而思路3是通过观察公式得来的，显然后者更优

##### #1030 距离顺序排列矩阵单元格
- 未通过
	- 没仔细读题，以为矩阵的位置是随机的
1. 排序
	- 先放入所有合适的位置，然后再排序
2. 桶排序【未了解】
3. 几何法
	- 直接按照距离添加单元格
- 思考
	- 知道有几何法，但是却连排序法都没做好，花费了较长的时间


##### #1062 最长重复子串

1.   动态规划
     -   使用了找最长回文子序列的模板，使用二维数组记录不同起始位置下的最长重复子串长度
     -   难点在于状态转移，最终使用的是先获取之前位置的最大长度，然后再尝试是否存在（最大长度+1）的子串。
     -   时间复杂度是O(n^3^)，空间复杂度是O(n^2^)



##### #1049 最后一块石头的重量Ⅱ

1.   动态规划/背包
     -   使用宏观的角度看这道题，会发现最后的石头一定是将现有的石头分成两堆后，两堆石头重量和之差。尽管这一方法并不总能够得到合法的结果，但是对于取得最小非负值能够证明是正确的（见官解）
     -   要使得最后一块石头的重量最小，那么就应该让被减的那一堆石头重量接近但不超过石头重量和sum的一半。因此，题目转变为得到小于sum/2的最大值
     -   为了得到最小该最大值，使用了动态规划。使用二维数组dp(i,j)表示前i块石头是否能够达到重量j

-   思考
    -   如果觉得产生了新的数字但是这些数字都是从现有数字中产生的，那么可以尝试用宏观角度来看问题，比如求和，使用公式来表示最终值，然后在推测其极值



##### #1091 二进制矩阵中的最短路径

1.   BFS
     -   如果在遍历过程中不希望更改原矩阵，则需要考虑记录遍历过的位置
     -   使用哈希表以及自定义的位置类，要注意自定义类需要重写equals()和hashCode()方法
     -   但上网搜索后发现使用新的boolean二维数组来记录位置是更好的选择



##### #1092 最短公共超序列

1.   动态规划
     -   这道题首先要用字符串的动态规划模板匹配最长公共子序列，然后通过得到的二维状态转移表组合成公共超序列

-   思考
    -   十分综合的困难题，动态规划难想但是易做，但是重组则需要规划路径



##### #1137 第N个泰波那契数

- 思路
  1. 见#509



##### #1140 石子游戏Ⅱ

1.   动态规划
     -   使用二维数组dp(i,j)表示从位置i之后，在m=j的限制下能够获得的最多石头数量
     -   当有机会取完所有石头时，取完；否则，让对手的石头数量最小，通过剩余石头数量减去对手可以获得的石头数量（这已被作为状态保存且被遍历过了）得到该结果



##### #1143 最长公共子序列

1.   动态规划

     -   创建动态数组dp，其中dp\[i][j]表示text1[0:i]和text2[0:j]的最长公共子序列的长度。得到状态转移方程

         ```
         dp(i,j)=dp(i-1, j-1)+1, text1[i-1]==text2[j-1]
         dp(i,j)=max{dp(i-1,j),dp(i,j-1)}, other
         ```

-   思路
    -   使用二维动态规划的时候：两个迭代器

##### #1161 最大层内元素和
- 未通过
	- 忽略了层元素和可能为负数的情况，导致了预设的初始值可能成为了最大层元素和

##### #1168 水资源分配优化

1.   最小生成树
     -   将井也视作一个节点，各个房屋到井的开销等于建设井的开销
     -   这样就能够把问题转换为最小生成树了

-   思考
    -   井的开销与房屋之间的距离是分开的，这对处理问题来讲很麻烦，所以需要通过一定处理将两者合并为同一个问题



##### #1203 项目管理

-   思路
    -   因为训练期间限定时间在40”，这题的工作量较大，不能在规定时间内完成
    -   自己没有提高做题速度的对策



##### #1209 安排会议日程

-   未通过
    -   没有说提供的数组是排序数组



##### #1231 分享巧克力

1.   二分查找
     -   巧克力切开后的最小甜度值在一个区间内，这个区间是【最不甜的巧克力块min，所有甜度总和sum】
     -   尽管这个区间很大，但是并非所有的情况都能够把巧克力分成k+1块
     -   所以二分查找的任务是从这两个区间种查找，找到最大的能够将巧克力分成k+1块的值

-   思考
    -   一开始想的是巧克力的位置应该怎么切，但是想不出
    -   这里的解法实际上并不在意每块巧克力怎么分开，只需要知道能不能分开
    -   思考问题的角度一定要从暴力入手，如果暴力无解，则可能是角度不对



##### #1235 规划兼职工作

1.   动态规划
     -   因为每个任务都有权重，所以需要使用动态规划搭配贪心的做法
     -   令每个状态为：选择该当前任务下，当前任务及之前的最大值。为了防止出现题目中未通过的情况，所以对最大值的遍历需要从头到尾
     -   使用二分查找优化寻找上一个符合条件的任务
2.   动态规划 优化
     -   令每个状态为：当前任务及之前的最大值。这样，每个状态中可以选择当前任务，也可以不选，直接套用上一个状态，只需要选择值更大的。
     -   这样不会出现未通过的情况，也不需要从头到尾进行遍历


-   未通过
    -   缺乏对终止时间相同情况的处理。比如出现了起始时间与终止时间完全相同的任务，但是后者的权重更高
-   思考
    -   动态规划很可能需要二分查找来进行优化



##### #1249 移除无效的括号

-   未通过
    -   两次遍历中，复制了第一次遍历的方法，但是参数没有调整好

1.   使用栈
2.   两次遍历
     -   使用栈只是为了确保删除多余而无法一次便察觉的'('，但是这可以通过第二次遍历，从右往左删除


##### #1262 可被三整除的最大和
- 思考
	- 被“选择最大”卡住了，最终通过看题解才知道了动态规划的做法

##### #1263 推箱子

-   未通过
    -   边界条件把x和y都写成了`<n` 
    -   把人的状态和箱子的状态分离了。为了简便性这是应该的，但是在设置visited数组的时候只设置了箱子的信息，没有设置人的信息。遇到的错误例子是人需要挪开箱子才能够到达合适的位置去推动箱子，因此箱子会出现两次到达同样地方的需求，但人的位置其实已经改变了。而我的visited数组只记录了箱子的位置，导致了找不到正确的结果



##### #1314 矩阵区域和

1.   二维前缀和
     -   为了提高计算速度，显然需要做空间换时间，于是使用了二维前缀和



##### #1345 跳跃游戏Ⅳ

1.   bfs
     -   超时
2.   bfs优化
     -   遍历完相同数字的列表后，将该列表删除以防止重新遍历

-   思考
    -   对于bfs，时间复杂度是O(V+E)，其中V是顶点的数量，E是边的数量
    -   在此题中，V=n，而E可能达到O(n^2^)的数量级，按照常规方法的bfs会超时。造成超时的原因是所有值相同的元素构成了一个稠密子图，普通的bfs会对这个稠密子图中的所有边都访问一次。但这是没有必要的，因此在优化过程中，每次遍历完该列表后，清空该列表



##### #1376 通知所有员工所需的时间

1.   bfs
     -   很容易看出来这道题尽管以一个一维数组的形式出现，但实际上其内在的数据结构是一棵树。既然其内在数据结构是一棵树，那么是否有必要将其重新转回树呢？显然是多此一举的
     -   为了提高遍历速度，使用了哈希表，以上司为键，员工队列为值。首先遍历员工数组，以完成哈希表的维护，然后进行常规的bfs即可
     -   时间复杂度和空间复杂度均为O(n)
2.   dfs
     -   使用新的数组记录最终通知时间
     -   遍历员工数组以获取所需时间，若员工的上司通知时间未获取，则先获取其上司通知时间，直到成功获取
     -   因为只需要一次遍历，且不需要维护哈希表，所以性能更优

-   思考
    -   中午困也不至于觉得树要重建吧。。。
    -   这个dfs方法优点在于不依赖树从上往下的顺序，所以不需要哈希表也能够完成

## 14+

##### #1408 数组中的字符串匹配
- 未通过
	- 没有考虑到重复的情况

##### #1422 分割字符串的最大得分
- 未通过
	- 忽略了分隔符的位置要求
	- 分割逻辑和想的不一致

##### #1434 每个人戴不同帽子的方案数

1.   动态规划
     -   令二维数组dp(i, mask)表示已经处理了前i顶帽子，并且已经被分配帽子的人的状态为mask时的方案数
     -   使用长度为n的二进制数表示每一个人的状态。在位处理上，通过`(mask>>j)&1`来判断mask的第j位是否为1，`mask-(i<<j)`将mask的第j位变为0
     -   遍历方向为：从1顶帽子开始
     -   如果第i顶帽子没有被分配给任何人，则状态为dp(i-1, mask)；如果帽子被分配给了第j个人，则状态为dp(i-1, mask')，由此得到状态转移

-   思考
    -   动态规划能够轻易表示帽子是否有被分配，且能够知道是否每一个人都戴上帽子了，而用帽子找人可以通过mask全为1时找到
    -   用帽子找人而不是人找帽子，这是因为帽子数量有40顶，超过了32位，不能够状态压缩
    -   状态压缩的动态规划是指通过这种掩码的方式作为一种状态


##### #1475 商品折扣后的最终价格
- 未通过
	- 又是等于号

##### #1478 安排邮筒

1.   动态规划

-   思考
    -   动态规划方程差在了转移没想出来。转移一定是小幅度动作
    -   这次的动态规划转移方程同时涉及了一个函数，如果认为这个函数只是不方便表达，但是可以计算，那么也可以写进来
    -   从n个数中找到一个点，使得该点到任意位置的距离最短，那么这个位置一定是个中位数



##### #1489 找到最小生成树里的关键边

1.   暴力Kruskal
     -   不断枚举每一条边是否关键

-   思考
    -   又出现了嫌弃暴力的思想，所以超时了



##### #1510 石子游戏Ⅳ

1.   动态规划

-   思考
    -   这是一道脑筋急转弯，在前面几道石子游戏后还在想怎么设置状态数组，但是在这题，如果对手输了那我就赢了。显然对于每个数字必然是我输或者对手输，基于这一观点设置动态规划即可



##### #1567 乘积为正数的最长子数组长度

>   动态规划

-   思路
    1.  该思路由#152思路一更改而得到
    2.  该思路与#152思路二类似，同时维护i的正数最长数组长度和负数最长数组长度



##### #1591 奇怪的打印机Ⅱ

1.   模拟
     -   很难看出哪种颜色是第一个填上的，但最后一个填上的颜色一定很容易看出
     -   不断将”最后一种颜色“以0填充，然后继续判断，直到方格中全为0

-   思考
    -   这道题是因为被提示了才做有思路的，对于难以入手的题目，应该从其显著特征入手

## 16+

##### #1624 两个相同字符之间的最长子字符串
- 未通过
	- 建模与题意不符

##### #1692 计算分配糖果的不同方式

1.   动态规划

     -   有状态dp(i,j)，其中i表示已经用了i个袋子，j表示已经装了j个糖果

     -   对于此时遍历到的一颗新糖果，可以选择放进用过的袋子中，也可以使用新的袋子。此时有状态转移

         `dp(i,j) = dp(i,j-1)*i + dp(i-1)(j-1)` 
         
     -   在遍历过程中要注意保持袋子数小于糖果数，否则计算的状态不符合

-   思考
    -   总是会觉得这类题目我只有通过dfs才能够做出来。因为数据量很大，且问的是方案数量而不是方案值，所以知道这需要使用动态规划来完成，但是却不知道怎么下手
    -   看到别人的题解也会很惊讶，觉得动态规划把这题诠释得太简单了。为了找到以后能够想到如何使用动态规划，无论对于什么题目，都应该关注其状态转移才行



##### #1697 检查边长度限制的路径是否存在

1.   bfs
     -   因为对于每一次查询，都需要知道确切的路径才可以确认是否有不超过限制的路径能够抵达终点，然而并查集没办法体现路径的长度信息，所以使用bfs进行排查
     -   先整理数据，将每个节点能够抵达位置的信息记录在新的数组中，然后使用bfs遍历，若节点之间的路径在限制范围以内，则加入队列中
     -   因为bfs需要对逐个节点进行遍历，且在该题中对每个查询都需要遍一次，没有办法记录其路径信息，所以必然超时
2.   并查集
     -   尽管并查集没有办法体现距离，但是可以通过在查询时刻仅连接在限制距离以下的路径达到效果。这需要先对查询和路径信息各通过限制距离、距离进行排序，然后随着查询的限制距离的增加，不断连接符合要求的节点

-   思考
    -   通过边维护边遍历解决了距离的限制



##### #1751 最多可以参加的会议数目

-   未通过
    -   在答案中把自己写的工具类也写进来了
    -   思考的方向错了

1.   动态规划

-   思考
    -   最初思考的方向错了。我先对会议的开始时间进行排序，然后使用了多状态的动态规划来做这道题。但这不能保证除第一次外的动态规划结果是正确的。而且因为同时还要维护会议的结束时间来避免冲突，我使用了三维的dp数组，也使得结果不直观。
    -   上面方法做不出来是因为排序结果对问题帮助不大，最终卡在了一些起点很小但跨度很大，却又偏偏值不大不小，最终导致了占着茅坑不拉屎的现象出现了，导致了一些值更小但跨度不大的会议没办法加入到动态规划数组中
    -   因为只有结束时间需要额外留意，所以应该对会议的结束时间进行排序以解决问题



##### #1786 从第一个节点出发到最后一个节点的受限路径数

-   未通过
    -   把“小于等于”和“小于”混淆了
    -   做了记忆化，但是记忆化的默认值0是一个可能的结果。这导致了初始化犹如多余的存在



##### #1823 找出游戏的获胜者

1.   暴力模拟

     -   用链表来模拟环
     -   使用双链表来提高速度

2.   动态规划

     -   因为过程涉及状态的变化，因此应该想到使用动态规划
     -   第一轮状态记作f(n,k)，下一轮则记作f(n-1,k)，如果能够找到n个人参赛与n-1个人参赛的最终胜出者之间的关系，就能够推导出状态转移公式
     -   画表格比较

     ```
     初始:		1,2,...,k-1,k,k+1,...n
     淘汰后:	1,2,...,k-1,k+1,...n
     下一轮:	k+1,...,n-1,n,1,...,k-1
     ------
     假设知道下一轮的胜出者为x，即f(n-1,k)=x，则有
     默认视角：	1,2,...,x-1,x,x+1,...n
     偏移后：	 k+1,...,k+x,...,k-1
     ```

     -   可以发现偏移量为k，因此得到状态转移方程：

         `f(n,k)=(f(n-1,k)+k-1)%i+1` （为防止刚好整除的情形导致取模为0，对原值-1后再对模+1）。而当只有一个人参赛时，最终结果只有他自己，即`f(1,k)=1`

     -   根据状态转移方程可以发现当前状态只与前一项有关，因此优化后，时间复杂度为O(n)，而空间复杂度为O(1)

-   思考
    -   状态的改变要想到动态规划



##### #1845 座位预约管理系统

1.   使用数组模拟座位
     -   通过循环遍历找到下一个为空的座位
2.   使用堆
     -   因为座位的预约数总是小于座位数，且所有操作合理，不会溢出，于是选择预约数进行维护。所以使用堆

-   思考
    -   想着这题没办法优化了，所以心安理得的使用了数组+循环遍历
    -   原来转换焦点会发现自己做了多余的事



##### #1857 有向图中最大颜色值

1.   拓扑+动态规划
     -   使用拓扑使得能够从前往后地遍历，使用二维状态数组记录当前位置所有颜色的最大值



##### #1901 找出顶峰元素Ⅱ

-   严重超时，且没能使用二分法解决



##### #1928 规定时间内到达终点的最小花费

1.   动态规划

-   思考
    -   这是通过逐个时间点地遍历得到的结果，效率虽然不如逐个节点遍历高，但仍比直接dfs要好



##### #5863 统计特殊四元组

> 数组

- 思路
  1. 通过循环初始条件使得四个元素皆不相同，然后通过四重循环条件得到题解



##### #5864 游戏中弱角色的数量

>数组

- 思路
  1. 应该控制顺序，先比较第一个数并排好序，再比较第二个数是否比排序在其前最小一个数还要小。二维数组的排序可以通过`Arrays.sort(T[] a, Comparator<? super T> c)`重写其`compare()`方法，再自定义比较



##### #5868 可互换矩形的数组

- 思路

  1. 忽略了返回类型是long类型，也缺乏对数字最大值的概念，所以出了错

- 提示

  1. 哈希表HashMap同样可以遍历。除此之外，foreach变量可以把各种类型用var指代

     ```java
     for (var x:map.values()) { // long x:
                 cnt += x*(x-1)/2;
     }
     ```

  2. 哈希表的修改、添加可以简写（有则加一，无则加入）

     ```java
     for(var data:rectangles){
                 double convert = (double)data[0]/data[1];
                 map.put(convert, map.getOrDefault(convert, 0L)+1L);
           }
     ```

     

##### #6017 向数组中追加k个整数

1.   暴力
     -   先对该数组进行排序，然后从0开始遍历，检查当前值是否在数组中，如果不在，则加起来。尽管该方法的时间复杂度为O(n)，但是由于数值十分大，所以还是超时了


##### # LCP19 秋日收藏集

1.   3种状态的动态规划
     -   将红叶区1、黄叶区，红叶区2各视为一种状态，然后使用动态规划
2.   暴力
     -   枚举红叶区1、黄叶区，红叶区2的分割点
3.   前缀和
     -   暴力法的时间复杂度为O(n^2^)会超时，所以使用前缀和优化任意一个分区之间的分割点
     -   最后的交换次数能够使用表达式表示，能

-   思考
    -   一开始读错题了，以为是交换叶子
    -   对于区间划分不明确的求解，应该使用多状态的动态规划
    -   暴力是所有算法的基础。如果找不到所有暴力的方法，说明角度可能不对
    -   时间换空间的手段：动态规划、前缀和



##### # LCP22 黑白方格画

-   未通过
    -   漏了0
    -   循环写错了，导致只有一层
    -   循环重复了
-   思考
    -   暴力确实不被待见，但不应该被拒绝。这道题的数据量不大，暴力也是0ms。因为找到公式之后就束手无策了，所以也只能够使用暴力
    -   $C^m_n = \frac{n!}{m!(n-m)!}$ 



