​	在开发应用的过程中遇到了这样的问题：我希望在app第一次运行时会初始化数据库，填充一些基础数据；然后app查询数据库并将其中内容更新到view中。其中，初始化填充数据和查询都在独立的线程中运行，但是由于初始化的步骤中还需要设置一些SharedPreference的参数导致初始化的工作耗时相对较长，这导致了查询到空数据的问题出现。

​	为了尝试还原这个问题，可以把数据库理解成你的钱包余额。默认情况下余额为0，你需要先赚钱才能消费，但赚钱的耗时总是要相对漫长的。以下的代码有四个类，分别是个人钱包Account类，赚钱行为的GetMoneyJob类，消费行为的ConsumeJob类，以及用于测试代码的MyWork类。

​	从main()函数来看，赚了100块，然后花费12块（可能是买奶茶吧），看起来很合理。但是运行过程中会发现扣钱比赚钱来得更早，这听起来可就不合理了。

```java
public class Temp {
	static Account account;
	public static void main(String[] args) {
		account = new Account(0);
        GetMoneyJob getMoneyJob = new GetMoneyJob(100);
        ConsumeJob consumeJob = new ConsumeJob(12);
        Thread a = new Thread(getMoneyJob);   
        Thread b = new Thread(consumeJob);
        a.start();
        b.start();   
	}
}

class GetMoneyJob implements Runnable{
	int value;
	
	
	public GetMoneyJob(int value) {
		this.value = value;
	}


	@Override
	public void run() {
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		Temp.account.use(-value);
	}
}

class ConsumeJob implements Runnable{
	int value;
	
	
	public ConsumeJob(int value) {
		this.value = value;
	}


	@Override
	public void run() {
//		try {
//			Thread.sleep(3000);
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
		Temp.account.use(value);
	}
}

class Account{
	int balance;
	
	public Account(int balance) {
		this.balance = balance;
	}
	
	public void use(int value){
		balance -= value;
		System.out.println(balance);
		if(balance < 0)throw new NullPointerException();
	}

}
```

